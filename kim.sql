select * from tab; --코드 옆에서 ctrl + ENTER 치면 data가 아래에 나옴
select * from PERSONNEL;
select * from DIVISION;
select * from bonus;
select pno,pname,pay,dno from personnel;

--distinct 중복제외
select distinct job from personnel;

--정렬order by
ORDER BY pay ASC; --오름차순
SELECT pno, pname, pay FROM personnel ORDER by pname;

--ASC = ascending은 default 생략가능
select pno,pname,pay from personnel order by pname; --ORDER BY만 있으면 ASC 가 생략?(ASC 기능포함)
--정렬은 temp.dbf에 펼쳐놓고 정리

SELECT pno, pname, pay from personnel ORDER BY pay DESC; --내림차순

SELECT * from personnel order by startdate DESC;

--사원번호가 높은 순서대로 정렬하시오
--회사에서는 *별표 잘 안씀
--* 는 전체라는 뜻
--데이터양이 어마어마어마어마어마무시함 조심!!
--DB 터짐 퇴사각 
--특정 데이터 사용할때만!

SELECT * FROM personnel ORDER BY pno DESC;--이 코드 대신 아래 DESC PERSONNEL;사용

SELECT * FROM PERSONNEL;

DESC PERSONNEL;
DESCRIBE PERSONNEL;--이걸 줄여서 위의 코드와 같음.오라클은 10000을 넘지 못함

SELECT PNO, PNAME, PAY+1000 FROM PERSONNEL;--PAY+1000-> 파생컬럼: 급조된 컬럼(방금 만들어진 컬럼)
--SELECT PNO, PNAME, PAY+1000 AS 보 너 스 FROM PERSONNEL; ->오류남. 띄어쓰기 안하고
SELECT PNO, PNAME, PAY+1000 AS 보너스 FROM PERSONNEL;
--SELECT PNO, PNAME, PAY+1000 AS '보' '너' '스' FROM PERSONNEL;-> 안?
SELECT PNO, PNAME, PAY+1000 AS "보_너_스" FROM PERSONNEL;--띄어쓰기는 언더바 _사용함. 무조건 ""큰따옴표 사용.-as가 닉네임설정 가능하게 함.작은 따옴표 무조건 안?
SELECT PNO, PNAME, PAY+1000 보너스 FROM PERSONNEL;--AS 생략가능."" 큰따옴표도 생략가능.

SELECT PNO, PNAME, PAY, PAY+1000 보너스 FROM PERSONNEL ORDER BY 보너스; --ORDER BY는 *칭을 가져다 쓸수 있다
SELECT PNO, PNAME, PAY, PAY+1000 보너스 FROM PERSONNEL ORDER BY 4;--회사에서는 숫자 잘안씀. PNO, PNAME, PAY, PAY+1000의 4번째를 의미.

SELECT * FROM PESONNEL ORDER BY 4;--위 코드를 이와같이 가능.

SELECT DNO, PNO, PNAME FROM PERSONNEL ORDER BY DNO, PNO;

SELECT * FROM PERSONNEL ORDER BY DNO DESC PNO;
--부서번호 DNO는 오름차순, 사원번호 PNO는 내림차순 정렬
SELECT * FROM PERSONNEL ORDER BY DNO, PNO DESC;

SELECT * FROM PERSONNEL ORDER BY MANAGER ASC; --NULL이 맨 아래에 있을 수도 있기에 확인해야?-NULL찾는 명령어가 따로 있음
--TABLE 만들 때 절대 NULL을 만들지 말라함. NULL은 가장 큰값이다. 그러므로 DESC로 하면 바로 위에 뜸

--사원의 급여와 일년치 연봉(ANNUAL)을 구하시오
SELECT DNO, PNO, PNAME, PAY, (PAY*12) + NVL(BONUS, 0) ANNUAL_PAY FROM PERSONNEL; --BONUS가 NULL이므로 나머지 DATA가 NULL로 나옴
--NVL(BONUS, 0) -> 보너스가 있으면 그 보너스를 쓰는 것이고 아니면 0으로 표시해라.
--SELECT DNO, PNO, PNAME, PAY, NVL(BONUS, 0),(PAY*12) + BONUS ANNUAL_PAY FROM PERSONNEL;

SELECT PAY, PAY-500 FROM PERSONNEL;
SELECT PNAME || PNO FROM PERSONNEL; --컬럼의 값을 연결할 때 사용
SELECT PNAME || ' ' ||PNO FROM PERSONNEL; -- 문자는 ''작은 따옴표. 보기 좋게 띄어쓰기를 넣어보자
--컬럼에서 디비는 두개로 나뉘어서 각자 정보가 저장? ex) 사용자, 주소라고 하면 왼쪽 오른쪽 각각 저장되어 표로 보임

SELECT PNAME || ' ' ||PNO PNAME FROM PERSONNEL;--SELECT PNAME || ' ' ||PNO (AS)PNAME FROM PERSONNEL;

SELECT PNAME, PNO FROM PERSONNEL; -->컬럼.열(row) 제한

--WHERE 행 제한 조건문
SELECT * FROM PERSONNEL WHERE JOB = 'SALESMAN'; --소문자 salesman은 안? 오라클은 소문자가 대문자로 나옴/SQL은 소문자 가능
--연산자 : = , <. >. <=. >=
--오라클에서 <> : 같지않다

--급여가 1600인 사원 검색해라
SELECT * FROM PERSONNEL WHERE PAY = 1600;

--사원번호가 1116인 사원 검색
SELECT * FROM PERSONNEL WHERE PNO = 1116;

--사원의 급여가 2000 이하인 사원 검색
SELECT * FROM PERSONNEL WHERE PAY <= 2000;

--1990년 12월 17일에 입사한 사원
SELECT * FROM PERSONNEL WHERE STARTDATE = '1990/12/17';
SELECT * FROM PERSONNEL WHERE STARTDATE = '1990-12-17'; --가끔 적용안될 때도 있음
--날짜, 생년월일(안바뀌고 연산안하는 숫자는 문자로 표시해도 ?

--환경셋팅창보기
SELECT * FROM NLS_SESSION_PARAMETERS;
--RR/MM/DD -> 기본 OS의 날짜 형식

--업무가 CLERK인 사원
SELECT * FROM PERSONNEL WHERE JOB = 'CLERK';

--이름이 JAMES인 사원
SELECT * FROM PERSONNEL WHERE PNAME = 'JAMES';

--논리연산자
--AND, OR, NOT -> NOT은 !와 같다.
--AND는 조건이 두개가 같아야?

--EX) 부서번호가 10번이고 급여가 3000이상 사원
SELECT * FROM PERSONNEL WHERE DNO = 10 AND PAY >= 3000;

--직업이 SALESMAN이고 90년이후에 입사한 직원
SELECT * FROM PERSONNEL WHERE JOB = 'SALESMAN' AND STARTDATE >= '1991/1/1'; --또는 1990/12/31

--91년 9월에 입사한 직원
SELECT * FROM PERSONNEL WHERE STARTDATE >= '1991/9/1' AND STARTDATE <= '1991/9/30';

--OR
--부서번호가 10번이거나 급여가 3000이상인 사원검색
SELECT * FROM PERSONNEL WHERE DNO = 10 OR PAY >= 3000;

--직업이 MANAGER이거나 90년도 이전에 입사한 직원 검색
SELECT * FROM PERSONNEL WHERE JOB = 'MANAGER' OR STARTDATE < '1990/1/1';

--NOT(문자열 연산자)
--업무가 SALESMAN 이거나 CLERK인 직원
SELECT * FROM PERSONNEL WHERE JOB = 'SALESMAN' OR JOB = 'CLERK';
SELECT * FROM PERSONNEL WHERE JOB IN ('SALESMAN', 'CLERK'); --위 코드와 같은내용 (계속 OR를 쓰기 힘드니까)

--업무가 SALESMAN, CLERK이 아닌 지원을 찾으시오
SELECT * FROM PERSONNEL WHERE JOB <>'SALESMAN' AND JOB <>'CLERK';
SELECT * FROM PERSONNEL WHERE JOB NOT IN ('SALESMAN', 'CLERK'); -- NOT의 위치에 따라서 부정하는 내용이 다름

--급여가 1000에서 2000인 사원
SELECT * FROM PERSONNEL WHERE PAY >= 1000 AND PAY <= 2000;
SELECT * FROM PERSONNEL WHERE PAY BETWEEN 1000 AND 2000;--위 코드와 같음
 
SELECT * FROM PERSONNEL WHERE STARTDATE BETWEEN '1991/09/01' AND '1991/09/30';

--부서번호가 20과 30사이가 아닌 사원
SELECT * FROM PERSONNEL WHERE DNO NOT IN (20, 30);--20과 30을 찾아라
SELECT * FROM DIVISION;--부서번호 확인할수있는 TABLE

SELECT * FROM PERSONNEL WHERE DNO NOT BETWEEN 20 AND 30; --20부터 30까지 찾아라.위 코드와 다름

--91년 5월 1일부터 92년 2월 24일 사이에 입사한 사원이 아닌 직원 찾아라
SELECT * FROM PERSONNEL WHERE STARTDATE NOT BETWEEN '1992/5/1' AND '1992/2/24';

--이름이 A로 시작되는 사원정보 찾으시오
SELECT * FROM PERSONNEL WHERE PNAME LIKE 'A%';
--LIKE 뒤에 어떤 문자가 와도 좋아.
--LIKE로 무언가로 시작하는 단어 찾을때 사용
--여기선 A%. 자바에서 A*.
--*********무조건  %는 LIKE를 써야된다*********

--사원번호가 111_인 사원 --> 여기서 언더바_는 자릿수이다 _언더바 뒤에 어떠한 문자가 와도 좋다는 의미. 여기서 자릿수 4자리
--날짜와 문자는 꼭 작은 따옴표 해야?

--''안에 들어가는 것이 문자이기때문에 어떠한 문자가 오든 상관없음
SELECT * FROM PERSONNEL WHERE PNO LIKE '111_'; --언더바 뒤에 반드시 한 자리수가 온다
SELECT * FROM PERSONNEL WHERE PNO LIKE '111%';--%뒤에 무한 자릿수 가능
SELECT * FROM PERSONNEL WHERE PNO LIKE '1__1';--전제 4자리면서 가운데는 두자리.

--90년도에 입사한 사원
SELECT * FROM PERSONNEL WHERE STARTDATE LIKE '90%'; --다른 나라는 연도를 뒤에 쓰기 때문에 %90. %를 앞에 붙인다.
--1900년도 미만은 컴퓨터가 인식안함

SELECT * FROM PERSONNEL WHERE REGEXP_LIKE(PNO, '11[^2]');--정규화 표현식. ^는 아니라는 의미
--위와 같은 경우는 112가 나오면 안되지만 1112에서 111이고 112 3자리씩 따져볼 수 있지만, 둘 중에 하나라도 참이면 나옴.
 
--1로 시작하고 뒤에 1 또는 2
SELECT * FROM PERSONNEL WHERE REGEXP_LIKE(PNO, '1[1, 2]');--자릿수는 마음대로임.

--이메일에서 정규화 표현식 해보자 - 아이디 추출하기
SELECT REGEXP_SUBSTR('NAY@GMAIL.COM', '[^@]+') 아이디 FROM DUAL; --한번만 나옴

SELECT REGEXP_SUBSTR('NAY@GMAIL.COM', '[^@]+') 아이디 FROM DIVISION; --DIVISION 갯수만큼 파생데이타(가상 데이타) 출력?

SELECT * FROM DUAL; -- DUMMY에 X로 출력되는데 아무 의미 없는 데이타..?

--MS-SQL은 문법만 써도 그냥 나옴.오라클에서만 FROM을 꼭 써줘야?
SELECT 100+300 FROM PERSONNEL; --부서 갯수만큼 출력
SELECT 100+300 FROM DUAL;--DUAL은 오라클에만 있다

--아까 했던 NULL에 대해 공부해보자
-- 아까도 말햇듯이 NULL값은 넣지말라고 했음
SELECT MANAGER FROM PERSONNEL WHERE MANAGER = NULL; --실행안?. NULL 찾은 것이 아님. 앞에 숫자가 아예 안들어있음. =는 문자를 찾기 때문에 여기서 NULL이라는 문자를 찾기에 안?
SELECT MANAGER FROM PERSONNEL WHERE MANAGER = 'NULL'; --실행안?

SELECT MANAGER FROM PERSONNEL WHERE MANAGER IS NULL;
--MS-SQL은 =기호로 사용해서 NULL을 찾을 수 있다

SELECT MANAGER FROM PERSONNEL WHERE MANAGER IS NOT NULL;
--_______________________________________________________________

--우선순위 매길 수 있음
--업무가 'Manager'이고 급여가 1500이상인 사원 또는 업무가
--A AND B OR C -> AND가 먼저 연산 후 OR가 연산됌
--'SALESMAN' 인 사원의 정보를 찾으시오

SELECT * FROM PERSONNEL WHERE (JOB = 'MANAGER' AND PAY >= 1500) OR JOB = 'SALESMAN';
--가로를 묶어준 것 부터 연산

--업무가 'PRESIDENT' 또는 'SALESMAN'이고 급여가 1500이상 사원 정보
SELECT * FROM PERSONNEL WHERE (JOB = 'PRESIDENT' OR JOB = 'SALESMAN') AND PAY >= 1500;
SELECT * FROM PERSONNEL WHERE JOB IN ('PRESIDENT', 'SALESMAN') AND PAY >= 1500;

--ORACLE FUNCTION 오라클 함수
--대표적인 숫자함수 : ROUND(반올림)
SELECT ROUND (45.275, 1) FROM DUAL;--45.3
SELECT ROUND (45.275, -1) FROM DUAL;--50

--자릿값
--  1  2  3  4 . 5 6 7
-- -4 -3 -2 -1 0 1 2 3 음수는 표시해라

SELECT PNO, PNAME, PAY, ROUND(PAY, -2) FROM PERSONNEL;

--TRUNC(절삭 - 자르기)
SELECT TRUNC(45.245, 2) FROM DUAL; --45.24
SELECT TRUNC(45.245, -1) FROM DUAL;--40

SELECT PNO, PNAME, PAY, TRUNC(PAY, -2) FROM PERSONNEL;

--CEIL/FLOOR (올림/내림) : 정수에서만 반환. 소수점 안됌
SELECT CEIL(461.21) FROM DUAL; --462
SELECT FLOOR(461.91) FROM DUAL; --461

--MOD : 나머지 구하기
SELECT MOD(10, 3) FROM DUAL; --1

--ABS : 절대값. 무조건 양수 만들어줌(잘 안쓰이는듯)
SELECT ABS(-123)FROM DUAL;--123
--실제로 가로()안에 컬럼을 쓰고 DUAL 대신 TABLE을 쓰면 됌

--SIGN(양수 1, 음수 -1, 0은 0)
SELECT SIGN(100), SIGN(-100), SIGN(0) FROM DUAL; --> 1 -1 0

--지수
SELECT POWER(2, 4) FROM DUAL; --16

--제곱근
SELECT SQRT(9) FROM DUAL; --3

--문자함수
--UPPER : 소문자 -> 대문자로 변환
SELECT UPPER('ORacle') FROM DUAL; --ORACLE
--LOWER : 대문자 -> 소문자로 변환
SELECT LOWER('ORacle') FROM DUAL; --oracle

SELECT DNO, DNAME FROM DIVISION WHERE DNAME = UPPER('sales');

--위 코드와 같아보이지만 위 코드보다 아래 코드가 더 느리다.
--느린 이유는 DNAME에서 LOWER로 소문자로 다 변환해서
--sales와 비교해서 데이터를 가져오기 때문에 느림
SELECT DNO, DNAME FROM DIVISION WHERE LOWER(DNAME) = 'sales';--섞어쓰면 안나옴
--SYSTEM 튜닝 --시스템적인 것 메모리 등 좋은것 쓰면 빨라짐
--SQL 튜닝 --튜닝처럼 바꿔줌

--INITCAP :첫글자만 대문자
SELECT INITCAP ('korea fighting') FROM DUAL;

--CONCAT
SELECT PNAME || DNO FROM PERSONNEL;
SELECT CONCAT(PNAME, DNO) FROM PERSONNEL;

--LENGTH: 공백포함 개수
SELECT LENGTH('KOREA FIGHTING') FROM DUAL; --14

--SUBSTR
SELECT SUBSTR('ABCDEFG', 1, 3) FROM DUAL; --ABC
SELECT SUBSTR('ABCDEFG', 3, 2) FROM DUAL; --CD
SELECT SUBSTR('ABCDEFG', -3, 2) FROM DUAL; --EF -> -3은 뒤에서 3번째
SELECT SUBSTR('ABCDEFG',-4) FROM DUAL; --DEFG

--INSTR
SELECT INSTR('ABCDEF','C') FROM DUAL; --3

SELECT INSTR('AAAAAAA', 'A') FROM DUAL; --1
SELECT INSTR('AAAAAAA', 'a') FROM DUAL; --0

--RPAD/LPAD
SELECT RPAD(PNAME, 15, '*') FROM PERSONNEL;
SELECT LPAD(PNAME, 15, '*') FROM PERSONNEL;

--RTRIM:오른쪽에서 부터 지워라/LTRIM: 왼쪽에서 부터 지워라 (공백 지울 때 사용.보통 잘 사용 안하는듯)
SELECT RTRIM ('ABBBBB', 'B') FROM DUAL;
SELECT RTRIM ('A         ', '') FROM DUAL;

SELECT RTRIM('ABBABB', 'B') FROM DUAL;

--날짜함수
--SYSDATE((GETDATE())
SELECT SYSDATE FROM DUAL;

--날짜함수
SELECT SYSDATE FROM DUAL;

SELECT SYSDATE + 4 FROM DUAL; --날짜는 기본적으로 연산이 됌 

SELECT STARTDATE -1, STARTDATE, STARTDATE +1 FROM PERSONNEL;

--KIM 사원이 오늘까지 근무한 년수 구하시오
SELECT PNAME, CEIL((SYSDATE - STARTDATE)/365) FROM PERSONNEL WHERE PNAME = 'KIM';
SELECT SYSDATE, STARTDATE, CEIL((SYSDATE - STARTDATE)/365) || '년' YEARS FROM PERSONNEL WHERE PNAME = 'KIM';

--ROUND
SELECT STARTDATE, ROUND(STARTDATE, 'YEAR') FROM PERSONNEL;

SELECT STARTDATE, ROUND(STARTDATE, 'MONTH') FROM PERSONNEL;

SELECT STARTDATE, ROUND(STARTDATE, 'DAY') FROM PERSONNEL;

--TRUNC
SELECT STARTDATE, TRUNC(STARTDATE, 'MONTH') FROM PERSONNEL;

--MONTHS_BETWEEN -달 수 구하기
SELECT ROUND (MONTHS_BETWEEN(SYSDATE, '1997/06/14')/12) YEAR FROM DUAL;

--LAST DAY
SELECT STARTDATE, LAST_DAY(STARTDATE) FROM PERSONNEL;

--NEXT DAY
SELECT NEXT_DAY(SYSDATE, '토요일') FROM DUAL;

--ADMONTHS
SELECT ADD_MONTHS(SYSDATE, 4) FROM DUAL;
SELECT ADD_MONTHS(SYSDATE, 24) FROM DUAL;

--변환함수
/*TO_CHAR(숫자나 날짜를 문자로 변경)
MM : 달수(10)
MON: 3문자 달 이름(MAR)
MONTH : 달의 전체이름 풀네임 (MARCH)
DD : 달의 날짜 수 (22)
D : 주의 일수(2)
DY : 3문자의 요일 이름 (MON)
DAY : 일의 풀네임. 전체이름 (화)
YYYY : 4자자리 연도
YY : 2자리 연도
RM : 로마식 달수
*/

SELECT SYSDATE, TO_CHAR(SYSDATE, 'D') FROM DUAL;
SELECT SYSDATE, TO_CHAR(SYSDATE, 'DY') FROM DUAL;
SELECT SYSDATE, TO_CHAR(SYSDATE, 'RM') FROM DUAL;
SELECT SYSDATE, TO_CHAR(SYSDATE, 'MON') FROM DUAL;
SELECT SYSDATE, TO_CHAR(SYSDATE, 'DAY') FROM DUAL;
SELECT SYSDATE, TO_CHAR(SYSDATE, 'YYYY-MM-DD') FROM DUAL;

SELECT SYSDATE, TO_CHAR(SYSDATE, 'YYYY-MM-DD') + 10 FROM DUAL; --문자는 연산이 안됌

SELECT SYSDATE, TO_CHAR(SYSDATE, 'DD-YYYY-MM') FROM DUAL;
SELECT SYSDATE, TO_CHAR(SYSDATE, 'DD-YY-MM') FROM DUAL;

--시간형식
/*
HH, HH12 오후 1시
HH24 -> HOURS 13시
MI -> MINUTES
SS -> SECONDS
SSSSSS ->SECOND 자릿수
AM, PM = A.M, P.
*/

SELECT TO_CHAR(SYSDATE, 'HH24:MI:SS') FROM DUAL;
SELECT TO_CHAR(SYSDATE, 'AM HH:MI:SS') FROM DUAL;

--숫자형식
/*
9: 자릿수가 (9999-> 1218)
0: 자릿수가 비면 0으로 표시 (09999 -> 01234)
PR : 음수 (9999, PR -><1234>) .잘안쓰임
, : 천자릿수 (9,999 -> 1,000)
*/

SELECT TO_CHAR(12506, '$099,999.99') FROM DUAL;

--서수
--SP, TH
SELECT SYSDATE, TO_CHAR(SYSDATE, 'DD') FROM DUAL;
SELECT SYSDATE, TO_CHAR(SYSDATE, 'DDSP') FROM DUAL;
SELECT SYSDATE, TO_CHAR(SYSDATE, 'DDTH') FROM DUAL;
SELECT SYSDATE, TO_CHAR(SYSDATE, 'DDSPTH') FROM DUAL;

--TO_DATE
SELECT TO_DATE('22/06/04', 'YY/MM/DD') + 10 FROM DUAL;
SELECT TO_DATE('13:38', 'HH24:MI') FROM DUAL;
SELECT TO_DATE('01:38', 'HH12:MI') FROM DUAL;

--TO_NUMBER
SELECT TO_NUMBER('123') + 100 FROM DUAL;

SELECT TO_NUMBER('ABC') FROM DUAL; --숫자가 아니여서 실행안됌

--NVL
SELECT BONUS, NVL(BONUS, 0)FROM PERSONNEL;

SELECT MANAGER FROM PERSONNEL;

DESC PERSONNEL;

SELECT MANAGER, NVL(TO_CHAR (MANAGER), 'NON MANAGER') FROM PERSONNEL; --실제로는 잘 안쓰이는듯

--DECODE: 한번에 처리 JAVA의 IF처럼~
--각 사원 급여 부서번호가 10인 경우 10%,  부서번호가 20인 경우 20%, 나머지 부서는 30% 증가

SELECT PNAME, BONUS, DNO, PAY, DECODE(DNO, 10, PAY*1.1, 20, PAY*1.2, PAY*1.3) 인상분 FROM PERSONNEL;

--급여가 3500 이상인 경우에는 GRADE를 'GOOD' 을 미만인 경우에는 'POOR' 출력
SELECT PNAME, BONUS, DNO, PAY, DECODE(SIGN(PAY - 3500), 1, 'GOOD', 0, 'SOSO', 'POOR')GRADE FROM PERSONNEL;
SELECT PNAME, BONUS, DNO, PAY, DECODE(GRADE SIGN(PAY - 3500), 1, 'GOOD', 'POOR') FROM PERSONNEL;--실행안됌

--SIGN(양수 1, 음수 -1, 0은 0)
SELECT SIGN(100), SIGN(-100), SIGN(0) FROM DUAL; --> 1 -1 0

--그룹함수 : COUNT
SELECT COUNT(*) FROM PERSONNEL; --무조건 데이터를 하나만 보여준다=하나만 출력

--급여가 3000이상인 사원의 수
SELECT COUNT(*) FROM PERSONNEL WHERE PAY >= 3000; --무조건 결과 1개 출력이므로 누군지 PNAME 알 수 없음

SELECT COUNT(MANAGER) FROM PERSONNEL;-- NULL값 때문에 하나 빠짐
SELECT COUNT(BONUS) FROM PERSONNEL; -- NULL값 제외 3

--AVG
SELECT AVG(PAY) FROM PERSONNEL;

--SUM:합계
SELECT SUM(PAY) FROM PERSONNEL; --총합계

--MAX/MIN
SELECT MAX(PAY), MIN(PAY) FROM PERSONNEL;

--사원중 입사한지 가장 오래된 직원
SELECT MIN(STARTDATE) FROM PERSONNEL;


--입사한지 가장 오래된 사원과 신입사원과의 연차 차이
SELECT ROUND ((MAX(STARTDATE)- MIN(STARTDATE))/365) AS 년 FROM PERSONNEL;-------?

SELECT * FROM PERSONNEL;

--분석함수
--부서별 평균

--여러개의 데이타에서 하나씩만 보여주는 것이  DISTINCT
SELECT DISTINCT DNO, AVG(PAY) OVER(PARTITION BY DNO) FROM PERSONNEL;
SELECT DNO, AVG(PAY) OVER(PARTITION BY DNO) FROM PERSONNEL;

--OVER : 그 위에~ OVER(PARTITION BY DNO)-> (PARTITION BY DNO)안에서

--월급 1200을 받는 사람 순위
SELECT * FROM PERSONNEL ORDER BY PAY DESC;

SELECT RANK(1200) WITHIN GROUP(ORDER BY PAY DESC) FROM PERSONNEL;

-- WITHIN GROUP: ~그룹 안에서

SELECT PNAME, PAY, RANK() OVER(ORDER BY PAY DESC) "RANK" FROM PERSONNEL;
--RANK() OVER(ORDER BY 컬럼) 문법 외우기. 동일 순위인 경우 1,1,3, 형식으로 출력하지만
-- ROW_NUMBER() OVER() ** 중요  제일 많은 씀 ** 동일순위인 경우 1, 2, 3 형식으로 출력
-- DENSE_RANK() OVER()는 동일 순위인 경우 1,1,2 형식으로 출력
-- ROW_NUMBER() OVER()는 매우매우매우 중요한 함수이므로 반드시 알아 둘것 !!!!!!

--GROUP BY 다중값 반환 쿼리
SELECT PNAME FROM PERSONNEL;

SELECT * FROM PERSONNEL WHERE PAY = 1600; --다중값 반환 쿼리(여러개)

SELECT COUNT(*) FROM PERSONNEL; --단일값 반환 쿼리(하나)

--단일값과 다중값을 같이 사용불가

SELECT PNAME, MIN(STARTDATE) FROM PERSONNEL; --X

SELECT MIN(STARTDATE) FROM PERSONNEL;
--하위쿼리
SELECT PNAME, STARTDATE FROM PERSONNEL WHERE STARTDATE = (SELECT MIN(STARTDATE) FROM PERSONNEL);
--위 코드가 이와 같은 결과인 것.
--SELECT PNAME, STARTDATE FROM PERSONNEL WHERE STARTDATE = '1989-01-10 00:00:00';

--부서별 평균 급여
--(종류)별로 구할 때는 GROUP BY 사용
SELECT DNO, AVG(PAY) FROM PERSONNEL GROUP BY DNO;

SELECT STARTDATE,
EXTRACT(YEAR FROM STARTDATE) 년,
EXTRACT(MONTH FROM STARTDATE) 월,
EXTRACT(DAY FROM STARTDATE) 일 
FROM PERSONNEL;

--각 부서의 평균 급여가 전체 평균 급여(2972.5)보다 크면 GOOD 아니면 POOR
SELECT ROUND(AVG(PAY)) FROM PERSONNEL;

SELECT DNO,AVG(PAY),
DECODE (SIGN (AVG(PAY) - (SELECT AVG(PAY) FROM PERSONNEL)),
1, 'GOOD', 'POOR') AS GRADE
FROM PERSONNEL GROUP BY DNO HAVING DNO = 20;
--SELECT 조건문 WHERE 사용
--GROUP BY 조건문 HAVING 사용

