select * from tab; --코드 옆에서 ctrl + ENTER 치면 data가 아래에 나옴
--한줄주석
/* 여러주석*/
select * from CUSTOM;

SELECT * FROM COMPANY;

SELECT USERID, PAY, ROUND (PAY, -4) PAY FROM COMPANY;

select * from CUSTOM;

--주민번호 * 표시 만들기 :970614-2******
SELECT RPAD(SUBSTR(JUMIN, 1, 8), 14, '*') JUMIN FROM CUSTOM;

SELECT COUNT(*) INWON FROM CUSTOM WHERE JOB = '회사원';

SELECT COUNT(*) INWON FROM CUSTOM WHERE ADDR1 LIKE '서울%';

SELECT COUNT(*) INWON FROM CUSTOM WHERE POINT >= 200;

SELECT * FROM COMPANY;--TABLE의 이름과 COLUMN의 이름이 중복되면 잘못된 것이다. 하면 안된다

--대리가 받는 총금액
SELECT COUNT(PAY) FROM COMPANY WHERE POSIT = '대리';
--SUM: 합계
SELECT SUM(PAY) FROM COMPANY WHERE POSIT = '대리';

SELECT * FROM CUSTOM;

--직업별 인원수
SELECT JOB, COUNT(*) INWON FROM CUSTOM GROUP BY JOB;

--학력별 POINT의 평균
SELECT SCHOL, ROUND(AVG(POINT)) INWON FROM CUSTOM GROUP BY SCHOL;

--지역별 POINT의 합계
SELECT ADDR1, ROUND(SUM(POINT)) INWON FROM CUSTOM GROUP BY ADDR1;

SELECT ADDR1, ROUND(SUM(POINT)) INWON, MAX(POINT)"MAX", MIN(POINT) "MIN" FROM CUSTOM GROUP BY ADDR1;


-- 성별 나이의 평균 인원수
SELECT SEX, ROUND(AVG(AGE)) "AVG", COUNT(*) "CNT" FROM CUSTOM GROUP BY SEX;

SELECT CASE SEX WHEN '1' THEN '남자' WHEN '0' THEN '여자'
END GENDER, ROUND(AVG(AGE)) "AVG", COUNT(*) "CNT" FROM CUSTOM GROUP BY SEX;
/*
SELECT 
CASE 컬럼명                         
	WHEN 1 THEN 100,                          
	WHEN 2 THEN 200,                         
	WHEN 3 THEN 300,                         
	WHEN 4 THEN 400                          
	ELSE 500                        
END AS RESULT(RESULT->파생 컬럼명)            
FROM DUAL;
*/

--하나일 때는 WHEN 1 THEN 100  ELSE 0 처럼 쓴다

SELECT*FROM COMPANY;
--직책별 전체 월급의 합계, 평균, MAX, MIN
SELECT POSIT, COUNT(*) CNT, ROUND(AVG(PAY)) 평균, MAX(PAY) 최대,
MIN(PAY) 최소 FROM COMPANY GROUP BY POSIT;

HAVING CNT > 60; --  COUNT(*)실제 데이터를 복숩.*표시 바꿀수 없음.*칭 사용못함.

------2021.01.25.화-------------

select A, B, D, A, E, F FROM AA(TABLE NAME), BB(T.N)
WHERE AA.A = BB.A -->이게 JOIN. 내가 가져오자하는 데이터를 가져오는 것

--select A, B, D, A, E, F FROM AA(TABLE NAME), BB(T.N) ->분자
--WHERE AA.A = BB.A ->분모

--JOIN
SELECT CUSTOM.USERID, USERNAME, ADDR1, COMPANY.USERID, DEPT, POSIT, PAY
FROM CUSTOM, COMPANY
WHERE CUSTOM.USERID = COMPANY.USERID;

--오라클 SQL EQUI JOIN(이제는 거의 둘다 쓰임)
SELECT A.USERID, USERNAME, ADDR1, B.USERID, DEPT, POSIT, PAY
FROM CUSTOM A, COMPANY B
WHERE A.USERID = B.USERID;

/*
EQUI JOIN(INNER JOIN) --가장 많이 사용
NON-EQUI JOIN -오라클에만 있는 JOIN.거의 사용안함
OUTER JOIN-거의 사용안함
CROSS JOIN-거의 사용안함
SELF JOIN-알아야?
*/

--ANSI 표준 SQL :INNER JOIN-여러가지 테이블 비교할때
SELECT A.USERID, USERNAME, ADDR1, B.USERID, DEPT, POSIT, PAY
FROM CUSTOM A INNER JOIN COMPANY B
ON A.USERID = B.USERID;--동등JOIN
--JOIN 조건문은 ON

--테이블 CUSTOM에서  USERID, USERNAME 검색 후
--POINT 테이블에서 제품 구입, 로그인 관계된 POIN점수(PRODUCT, LOGIN)검색

SELECT * FROM POINT;
SELECT A.USERID, USERNAME, PRODUCT, LOGIN
FROM CUSTOM A, POINT B
WHERE A.USERID = B.USERID AND LOGIN;

SELECT A.USERID, USERNAME, PRODUCT, LOGIN
FROM CUSTOM A, POINT B
WHERE A.USERID = B.USERID AND LOGIN;

--도구-쿼리설정-모든 데이터 FETCH하면 실핼 할 때마다 모든 데이터 출력

SELECT * FROM POINT;
SELECT A.USERID, USERNAME, PRODUCT, LOGIN
FROM CUSTOM A, POINT B
WHERE A.USERID = B.USERID AND LOGIN >= 10;

SELECT * FROM POINT;
SELECT A.USERID, USERNAME, PRODUCT, LOGIN
FROM CUSTOM A INNER JOIN POINT B
WHERE A.USERID = B.USERID AND LOGIN;

--OUTER JOIN
--특정 테이블이 기준이 되어서 데이터를 찾아옴

SELECT COUNT(*) FROM CUSTOM; --459
--(원래는 COMPANY보다 데이타수가 많아야되지만
--오류로 인해 데이터가 덜들어간 상태)

SELECT COUNT(*) FROM COMPANY; --464

SELECT A.USERID, USERNAME, ADDR1, COMPANY, DEPT
FROM CUSTOM A, COMPANY B
WHERE A.USERID = B.USERID;

--기본은 INNER JOIN
--459데이타인 CUSTOM을 기준으로 두면,
SELECT A.USERID, USERNAME, ADDR1, COMPANY, DEPT
FROM CUSTOM A, COMPANY B
WHERE A.USERID = B.USERID(+);--A를 기준

SELECT A.USERID, USERNAME, ADDR1, COMPANY, DEPT
FROM CUSTOM A, COMPANY B
WHERE A.USERID(+)= B.USERID;--B로 기준

SELECT A.USERID, USERNAME, ADDR1, COMPANY, DEPT
FROM CUSTOM A LEFT OUTER JOIN COMPANY B--왼쪽인 CUSTOM이 기준일때
ON A.USERID = B.USERID;

SELECT A.USERID, USERNAME, ADDR1, COMPANY, DEPT
FROM CUSTOM A RIGHT OUTER JOIN COMPANY B
ON A.USERID = B.USERID;

SELECT * FROM research;
SELECT COUNT(*) FROM RESEARCH;

SELECT A.USERID, USERNAME, ANSWER
FROM CUSTOM A, RESEARCH B
WHERE A.USERID = B.USERID(+);--A로 기준

SELECT A.USERID, USERNAME, ANSWER
FROM CUSTOM A LEFT OUTER JOIN RESEARCH B
ON A.USERID = B.USERID;

--ANSWER을 안한 사람만 찾기
SELECT A.USERID, USERNAME, ANSWER
FROM CUSTOM A, RESEARCH B
WHERE A.USERID = B.USERID(+) AND ANSWER IS NULL;

SELECT A.USERID, USERNAME, ANSWER
FROM CUSTOM A LEFT OUTER JOIN RESEARCH B
ON A.USERID = B.USERID
WHERE ANSWER IS NULL;

--CROSS JOIN(상호조인)
SELECT COUNT(*) FROM CUSTOM;--459
SELECT COUNT(*) FROM COMPANY;--464

--INNER JOIN
SELECT A.USERID, USERNAME, ADDR1, COMPANY, DEPT
FROM CUSTOM A, COMPANY B;
--WHERE A.USERID = B.USERID;

--SELF JOIN : 2가지 방법 KIM과 LEE에서 하는 방법 알아보자
SELECT * FROM CUSTOM;

DESC CUSTOM;

--제약조건 중 중복값이 들어가면 안되는 UNIQUE라는 제약조건 있음
--이것을 USERNAME에 넣는다는 가정하면(보통은 USERNAME에 안씀)
--이렇게 검사하는 것을 SELF JOIN
SELECT A.*
FROM CUSTOM A, CUSTOM B
WHERE A.USERNAME = B.USERNAME
ORDER BY A.USERNAME;
--스스로 컬럼 여러개를 하나로 묶어서 JOIN으로 만든다->SELF JOIN

SELECT A.*
FROM CUSTOM A, CUSTOM B
WHERE A.USERNAME = B.USERNAME
AND A.USERID<>B.USERID
ORDER BY A.USERNAME;

--동명 3인 같은 경우
SELECT DISTINCT A.*
FROM CUSTOM A, CUSTOM B
WHERE A.USERNAME = B.USERNAME
AND A.USERID<>B.USERID
ORDER BY A.USERNAME;
--AND A.USERID<>B.USERID
--: 지금은 괜찮지만 나중에 데이터가 여러개 섞일 경우
--꼭 기본적으로 쓰임. 꼭 쓰기!! 문법.
--AND A.USERID<>B.USERID을 사용했을 때 동명이인만 출력

--CUSTOM TABLE에 '제주도'에 살고 있는 사람 중 동일 이름 갖는 행 검색
SELECT * FROM CUSTOM WHERE ADDR1 = '제주도';

SELECT DISTINCT A.*
FROM CUSTOM A, CUSTOM B
WHERE A.ADDR1 = '제주도'
AND A.USERNAME = B.USERNAME
AND A.USERID<>B.USERID
AND A.ADDR1 = B.ADDR1
ORDER BY A.USERNAME;

SELECT A.*
FROM CUSTOM A INNER JOIN CUSTOM B
ON A.USERNAME = B.USERNAME 
WHERE A.USERID<>B.USERID AND A.ADDR1 = '제주도' AND B.ADDR1 = '제주도'
ORDER BY A.USERNAME;

--3개이상의 table join
SELECT A.USERID, USERNAME, COMPANY, DEPT, PRODUCT, LOGIN
FROM CUSTOM A, COMPANY B, POINT C
WHERE A.USERID = B.USERID AND A.USERID = C.USERID;
--반드시 USERID 사용하기에 이러한 구조로 작성

--ANSI 표준
SELECT A.USERID, USERNAME, COMPANY, DEPT, PRODUCT, LOGIN
FROM CUSTOM A INNER JOIN COMPANY B
ON A.USERID = B.USERID INNER JOIN POINT C
ON A.USERID = C.USERID;

--UNION/ALL

SELECT* FROM CUSTOM;
--모든 데이터를 하나에 넣어놓은 것을 이제 나눠볼 것.

CREATE TABLE JEJU
AS
SELECT * FROM CUSTOM WHERE ADDR1 = '제주도';

CREATE TABLE KYUNG
AS SELECT * FROM CUSTOM WHERE ADDR1 = '경기도';

CREATE TABLE SEOUL
AS SELECT * FROM CUSTOM WHERE ADDR1 = '서울특별시';

----------------------------------------------------
--아래 코드로는 TABLE이 다르기 때문에 분류된 것이 아니라
--다른 TABLE을 각 각 출력하는 것
SELECT * FROM JEJU;
SELECT * FROM KYUNG;
SELECT * FROM SEOUL;

--아래코드로 하면 각 테이블이 섞여서 전체가 출력?
--왼쪽 USERID를 보면 정렬되어있는 것을 볼 수 있음
--그 이유는 PRIMARY KEY로 정렬된 것.
--나중에 PRIMARY KEY를 배울 때 알게?

SELECT * FROM JEJU
UNION
SELECT * FROM KYUNG
UNION
SELECT * FROM SEOUL;

--DROP TABLE SEOUL; --테이블 지울때

--SUB QUERY(하위쿼리):쿼리 안에 쿼리 넣기

--COMPANY 테이블에서 USERID, COMPANY, DEPT, PAY와 평균 월급 검색
SELECT USERID, COMPANY, DEPT, PAY, AVG(PAY) FROM COMPANY;--ERROR
--AVE(PAY)->단일값
SELECT ROUND(AVG(PAY)) FROM COMPANY;--1782888

SELECT USERID, COMPANY, DEPT, PAY, 1782888 AVG_PAY FROM COMPANY;

--쿼리 안에 쿼리 넣기
SELECT USERID, COMPANY, DEPT, PAY,
(SELECT ROUND(AVG(PAY)) FROM COMPANY) AVG_PAY--가로로 완전히 묶어서
FROM COMPANY;

--연산도 가능
SELECT USERID, COMPANY, DEPT, PAY,
PAY - (SELECT ROUND(AVG(PAY)) FROM COMPANY) AVG_PAY--가로로 완전히 묶어서
FROM COMPANY;

--CUSTOM 테이블에서 평균 나이 이상이 행들 검색
SELECT * FROM CUSTOM;

SELECT ROUND(AVG(AGE)) FROM CUSTOM;

SELECT*FROM CUSTOM WHERE AGE >= (SELECT AVG(AGE) FROM CUSTOM);
--테이블이 같아야?

--COMPANY 테이블에서 평균 월급보다 적은 월급을 받는 행 검색
SELECT ROUND(AVG(PAY)) FROM COMPANY;--1782888
SELECT * FROM COMPANY WHERE PAY < (SELECT AVG(PAY) FROM COMPANY);


--'현대 자동차' 회사에 근무하는 고객의 USERID, USERNAME, ADDR1, SCHOL 열 검색
SELECT*FROM COMPANY WHERE COMPANY LIKE '현대자동차%';

SELECT * FROM CUSTOM
WHERE USERID = 'EE9224' OR USERID = 'el3409';

SELECT * FROM CUSTOM
WHERE USERID IN('EE9224','el3409');

SELECT * FROM CUSTOM
WHERE USERID IN (SELECT USERID FROM COMPANY WHERE COMPANY LIKE '현대자동차%');

SELECT * FROM COMPANY;
--JOIN

SELECT A.USERID, USERNAME, ADDR1, SCHOL, COMPANY
FROM CUSTOM A, COMPANY B
WHERE A.USERID = B.USERID
AND COMPANY LIKE '현대자동차%';

SELECT A.*, B.COMPANY
FROM CUSTOM A, COMPANY B
WHERE A.USERID = B.USERID
AND COMPANY LIKE '현대자동차%';

--SALSES 테이블에서 4회 이상 판매기록이 있는 고객들의 기본정도 검색
SELECT * FROM SALES
ORDER BY USERID;--물건구매 횟수 확인가능

SELECT USERID--, COUNT(*) CNT->4회이상 판매 다나옴
FROM SALES
GROUP BY USERID
HAVING COUNT(*) >= 4;--별칭(내가 이름 못지음) 못씀

--하위쿼리
SELECT USERID FROM CUSTOM
WHERE USERID IN
(SELECT USERID FROM SALES
GROUP BY USERID
HAVING COUNT(*) >= 4);

--INLINE VIEW -안에 가상 데이타 있음
SELECT A.*
FROM ()A, ()B;

SELECT A.*, CNT
FROM CUSTOM A, --CUSTOM 자리에도 ()가상 데이터 넣을 수 있음
--기존의 데이타를 다른 테이블과 연관지어 만드는 사람이 쿼리 잘함...^^7
(SELECT USERID, COUNT(*) CNT FROM SALES GROUP BY USERID HAVING COUNT(*) >= 4) B
--(물건 4회이상 구입 정보)가상의 데이타여서
--테이블에는 AS 쓰면 안?
WHERE A.USERID = B.USERID;

SELECT A.*, CNT
FROM CUSTOM A, 
(SELECT USERID, COUNT(*) CNT FROM SALES
GROUP BY USERID) B
WHERE A.USERID = B.USERID AND CNT >=4;

--총 판매 금액이 100만원 이상인 CUSTOM 테이블에는 고객의 기본 정보

SELECT * FROM SALES;


--JOIN
SELECT A.*, CNT, HAP--CUSTOM
FROM CUSTOM A, 
(SELECT USERID , COUNT(*) CNT, SUM(PRICE) HAP FROM SALES
GROUP BY USERID
HAVING SUM(PRICE) >= 1000000) B
WHERE A.USERID = B.USERID;

SELECT USERID FROM SALES GROUP BY USERID HAVING SUM(PRICE) >= 1000000;

SELECT USERID, COMPANY, DEPT, PAY,
(SELECT ROUND(AVG(PAY)) FROM COMPANY) AVG_PAY--가로로 완전히 묶어서
FROM COMPANY;

--하위쿼리
SELECT * FROM CUSTOM
WHERE USERID IN
(SELECT USERID FROM SALES GROUP BY USERID HAVING SUM(PRICE) >= 1000000);

--ANY, ALL
--ANY 무조건 범위값 포함 = 최소값 보다 크다 >ANY. 
--ALL 범위값 포함 X = 최대값 보다 작다

SELECT POINT FROM CUSTOM
WHERE ADDR1 = '제주도'
ORDER BY POINT;
--가장 작은값 : 132(최소값)
--가장 큰 값 : 269(최대값)

/*
132 ~ 269
>ANY : 132보다 큰데이터
<ANY :269보다 작은 데이터
<ALL : 269보다 큰 데이터
>ALL : 132보다 작은 데이터
*/

SELECT USERID, USERNAME, POINT FROM CUSTOM
WHERE POINT > ANY (SELECT POINT FROM CUSTOM WHERE ADDR1 = '제주도');
--위 코드가 아래보다 훨씬 데이타 속도가 빠르다
--MS-SQL
SELECT USERID, USERNAME, POINT FROM CUSTOM
WHERE POINT > ANY (SELECT MIN(POINT) FROM CUSTOM WHERE ADDR1 = '제주도');

SELECT USERID, USERNAME, POINT FROM CUSTOM
WHERE POINT < (SELECT MAX(POINT) FROM CUSTOM WHERE ADDR1 = '제주도');
-------------------------------------------------------------------------
SELECT USERID, USERNAME, POINT FROM CUSTOM
WHERE POINT > ALL (SELECT POINT FROM CUSTOM WHERE ADDR1 = '제주도');

SELECT USERID, USERNAME, POINT FROM CUSTOM
WHERE POINT > (SELECT MAX(POINT) FROM CUSTOM WHERE ADDR1 = '제주도');
--------------------------------------------------------------------------
SELECT USERID, USERNAME, POINT FROM CUSTOM
WHERE POINT < (SELECT MIN(POINT) FROM CUSTOM WHERE ADDR1 = '제주도');--안?

SELECT * FROM CUSTOM
WHERE POINT = 131;

SELECT * FROM CUSTOM ORDER BY POINT;

UPDATE CUSTOM SET POINT = 131 WHERE USERID = 'nn4942';

----------------------------------------------------------------------------------

SELECT USERID, USERNAME, ADDR1, SCHOL FROM CUSTOM
WHERE USERID IN(SELECT USERID FROM COMPANY WHERE COMPANY LIKE '현대자동차%');

SELECT USERID, USERNAME, ADDR1, SCHOL FROM CUSTOM
WHERE USERID  = ANY(SELECT USERID FROM COMPANY WHERE COMPANY LIKE '현대자동차%');

SELECT USERID, USERNAME, ADDR1, SCHOL FROM CUSTOM
WHERE USERID NOT IN (SELECT USERID FROM COMPANYWHERE COMPANY LIKE '현대자동차%');

--SELECT USERID, USERNAME, ADDR1, SCHOL FROM CUSTOM
--WHERE USERID != ANY (SELECT USERID FROM COMPANY WHERE COMPANY LIKE '현대자동차%');

SELECT USERID, USERNAME, ADDR1, SCHOL FROM CUSTOM
WHERE USERID <>ALL(SELECT USERID FROM COMPANY WHERE COMPANY LIKE '현대자동차%');
----------------------------------------------------------------------------------

SELECT USERID, USERNAME, ADDR1, SCHOL FROM CUSTOM
WHERE USERID IN(SELECT USERID FROM COMPANY WHERE COMPANY LIKE '현대자동차%');

--상관쿼리
SELECT USERID, USERNAME, ADDR1, SCHOL FROM CUSTOM
WHERE EXISTS --EXITSTS나오면 상관쿼리라고 생각하면 ?
(SELECT * FROM COMPANY WHERE USERID = CUSTOM.USERID
--FROM CUSTOM와 CUSTOM.USERID의 CUSTOM이 같아야?
AND COMPANY LIKE '현대자동차%');

SELECT USERID, USERNAME, ADDR1, SCHOL FROM CUSTOM
WHERE NOT EXISTS --EXITSTS나오면 상관쿼리라고 생각하면 ?
(SELECT * FROM COMPANY WHERE USERID = CUSTOM.USERID
AND COMPANY LIKE '현대자동차%');

------------------------------------------------------------------------------------
SELECT * FROM CUSTOM WHERE ADDR1 = '경기도' AND AGE <= 20;

SELECT * FROM (SELECT * FROM CUSTOM WHERE ADDR1 = '경기도')A;

SELECT * FROM (SELECT * FROM CUSTOM WHERE ADDR1 = '경기도')A
WHERE A.AGE <= 20;
-------------------------------------------------------------------------------------
--PAIR 와이즈?--KIM 파일로 가서 확인해보자

---------------2021.02.03.목-----------------
--PL/SQL
DROP TABLE 사원;

create table 사원
(사원번호 number(10),
사원명 varchar2(10),
부서번호 number(2),
직급 varchar2(10),
우편번호 char(7),
주소 varchar2(50),
전화번호 char(15),
급여 number(5),
커미션 number(5),
입사일 date,
성별 char(6),
사수번호 number(10)
);

insert into 사원 values(2001,'이순신',10,'부장','125-365','서울 용산구','02-985-1254',3500,100,'1980-12-01','남자',null);
insert into 사원 values(2002,'홍길동',10,'대리','354-865','서울 강남구','02-865-1254',4000,'','2000-01-25','남자',2004);
insert into 사원 values(2003,'성유리',20,'사원','587-456','부산 해운대구','051-256-9874',2500,100,'2002-05-24','여자',2002);
insert into 사원 values(2004,'옥주현',30,'과장','987-452','서울 강남구','02-33-6589',5000,'','1997-03-22','여자',2001);
insert into 사원 values(2005,'길건',10,'대리','123-322','서울 성동구','02-888-9564',3000,100,'1999-07-15','여자',2004);
insert into 사원 values(2006,'한지혜',20,'사원','154-762','서울 송파구','02-3369-9874',2000,'','2003-05-22','여자',2005);
insert into 사원 values(2007,'박솔미',30,'대리','367-985','서울 영등포구','02-451-2563',3000,100,'2006-01-25','여자',2004);
insert into 사원 values(2008,'이효리',40,'사원','552-126','서울 중구','02-447-3256',2000,'','2001-02-02','여자',2007);

SELECT * FROM 사원;
DESC 사원;

COMMIT;

--------------------------------------------------------------------------------------------------------------------------------
--이 툴은 여기서 실행 안?
SET SERVEROUTPUT ON;--이것을 써야 화면에 출력이 ? --cmd

DECLARE --이름없는 PROCEDURE
TYPE FRISTTYPE IS RECORD--하나의 RECORD를 담을 자료형 만들기.
(A VARCHAR2, B VARCHAR2, C NUMBER); --DATA TYPE
--A 사원명, B 직급, C 급여

--위 코드를 더쉽게 쓰는 방법
--하나의 RECORD를 담을 자료형 만들기.
DECLARE
TYPE FIRSTTYPE IS RECORD
(A 사원.사원명%TYPE, B 사원.직급%TYPE, C 사원.급여%TYPE);
--A VARCHAR 이런식으로 해도 됨

CUS FIRSTTYPE;

BEGIN 
SELECT 사원명,직급,급여 INTO CUS FROM 사원 WHERE 사원번호=2001;

DBMS_OUTPUT.PUT_LINE('사원명  직급  급여');--자바의 SYSOUT (출력)
DBMS_OUTPUT.PUT_LINE('------------------');
DBMS_OUTPUT.PUT_LINE(CUS.A||'  '||CUS.B||'  '||TO_CHAR(CUS.C));--급여가 숫자라 문자로 변형
DBMS_OUTPUT.PUT_LINE('현재 질의한 계정은 '||USER||'입니다'); --USER는 시스템 변수(우리가 만든 변수X)
--우리가 접속한 LEE가 USER 안에 들어가 있음
DBMS_OUTPUT.PUT_LINE('현재 질의한 시간은 '||TO_CHAR(SYSDATE,'YYYY-MM-DD HH:MM:SS')||'입니다');
END;
--/로 실행
--위 코드를 실행하기 위해 CMD 가기

DECLARE
SAWON_RECORD 사원%ROWTYPE; --테이블의 모든 컬럼을 쓸때 ROWTYPE 씀
BEGIN
SELECT * INTO SAWON_RECORD FROM 사원 WHERE 사원번호=2002;
DBMS_OUTPUT.PUT_LINE('사원번호: '|| SAWON_RECORD.사원번호);
DBMS_OUTPUT.PUT_LINE('사원명: '|| SAWON_RECORD.사원명);
DBMS_OUTPUT.PUT_LINE('직급: '|| SAWON_RECORD.직급);
DBMS_OUTPUT.PUT_LINE('주소: '|| SAWON_RECORD.주소);
DBMS_OUTPUT.PUT_LINE('입사일: '|| SAWON_RECORD.입사일);
END;


DECLARE
TYPE SANAME_TYPE IS TABLE OF 사원.사원명%TYPE
INDEX BY BINARY_INTEGER;

TYPE JIK_TYPE IS TABLE OF 사원.직급%TYPE
INDEX BY BINARY_INTEGER;

SANAME_COL SANAME_TYPE;--타입을 콜럼에 넣겟다
JIK_COL JIK_TYPE;

I BINARY_INTEGER := 0;
 
BEGIN

--K는 변수
FOR K IN (SELECT 사원명, 직급 FROM 사원) LOOP
I := I + 1;
SANAME_COL(I) := K.사원명;
JIK_COL(I) := k.직급;
END LOOP;

DBMS_OUTPUT.PUT_LINE('사원명 직급');
DBMS_OUTPUT.PUT_LINE('-----------');

FOR J IN 1..I LOOP--1부터 I까지
DBMS_OUTPUT.PUT_LINE(RPAD(SANAME_COL(J), 12) || RPAD(JIK_COL(J), 9));
END LOOP;

END;--BEGIN의 END
--DECLARE는 한번 실행하면 사라지기 때문에 따로 파일로 저장해두고 필요시에 복사해 사용한다

-------------------------------------------------------------------------------------------

--저장 PROCEDURE

CREATE OR REPLACE PROCEDURE CHANGE_PAY
(V_SANO IN NUMBER, V_NEW_PAY IN NUMBER)
IS 
BEGIN
UPDATE 사원 SET 급여 = V_NEW_PAY WHERE 사원번호 = V_SANO; --EXEC CHANGE_PAY(2001, 5000);
COMMIT;
END CHANGE_PAY;

--PROCEDURE의 이름을 써도 되고 안해도 ?

--IS 위에 쓰는 변수는 매개변수.
--IS 아래 쓰는 변수는 내부에서 사용하는 변수.지역변수.
--IN :외부에서 받아내는 값을 의미. 생략가능.매개변수
--OUT :외부로 내보내주는 값.

EXEC CHANGE_PAY(2001, 5000);--UPDATE이므로 한번 실행하고 끝.
EXEC CHANGE_PAY(2002, 3000);

-------함수 만들기
CREATE OR REPLACE FUNCTION F_TAX
(V_SANO IN NUMBER)
RETURN NUMBER
IS
V_TAX NUMBER;
BEGIN
SELECT ((급여*12) + NVL(커미션, 0))*0.05 INTO V_TAX
FROM 사원 WHERE 사원번호 = V_SANO;

RETURN V_TAX;
END F_TAX;--함수이름 써도 되고 안해도 ?
--/

SELECT 사원번호, 사원명, 직급, 급여, 커미션, F_TAX(2001) TAX FROM 사원
WHERE 사원번호 = 2001;

---------------------------------------------------------------------

SET SERVEROUTPUT ON;
SET VERIFY OFF; --OLD와 NEW가 안보임

ACCEPT ID PROMPT '검색할 아이디를 입력하세요: ';
--입력한 아이디가 변수 ID 안으로 들어감

DECLARE 
TYPE GOGAK IS RECORD
(A CUSTOM.USERID%TYPE, B CUSTOM.USERNAME%TYPE,
C NUMBER(12, 2), D NUMBER(5));

CUS GOGAK;

BEGIN
SELECT C.USERID, C.USERNAME, S.합계, S.구입횟수 INTO CUS
FROM CUSTOM C,
(SELECT USERID, SUM(PRICE) 합계, COUNT(*) 구입횟수 FROM SALES
GROUP BY USERID) S
WHERE C.USERID = S.USERID
AND C.USERID = '&ID'; --치환변수. 저 위에서 입력받은 ID 값을 가져옴

--보여주기
DBMS_OUTPUT.PUT_LINE('아이디: ' || CUS.A);
DBMS_OUTPUT.PUT_LINE('이름: ' || CUS.B);
DBMS_OUTPUT.PUT_LINE('판매액: ' || CUS.C);
DBMS_OUTPUT.PUT_LINE('금  액: ' || CUS.D);

END;
--/
SELECT * FROM CUSTOM;
SELECT * FROM COMPANY;

--직책을 입력받아 그 직책의 급여의 총액, 평균 월급, 인원수 찾기

CREATE OR REPLACE PROCEDURE SEARCHJIK
(JIK IN VARCHAR2) 
IS
A NUMBER := 0;
B NUMBER (12, 2) := 0;
C NUMBER := 0;
BEGIN
SELECT SUM(PAY), AVG(PAY), COUNT(*) INTO A, B, C FROM COMPANY
WHERE POSIT = JIK GROUP BY POSIT;

DBMS_OUTPUT.PUT_LINE('급여 총액' ||A|| '원');
DBMS_OUTPUT.PUT_LINE('평균 월급' ||B|| '원');
DBMS_OUTPUT.PUT_LINE('인원수' ||C|| '명');

END SEARCHJIK;

---------------------------------------------------------
--테이블 하나 만들 거얍
CREATE TABLE TEST
(A NUMBER(10), B NUMBER(10), C DATE DEFAULT SYSDATE);

CREATE OR REPLACE PROCEDURE P_EX
(FIRST IN NUMBER, SECOND IN NUMBER)
IS
BEGIN
INSERT INTO TEST(A, B) VALUES(FIRST, SECOND);
COMMIT;
END;
--/

 EXEC P_EX(10, 20);
 
 SELECT * FROM TEST;
 
 -----------여기서 문제
 
 --CUSTOM 테이블에 INSERT 시키는 프로시져 (CUS_IN)
 --CREATE OR REPLACE PROCEDURE CUS_IN;
 
 CREATE OR REPLACE PROCEDURE CUS_IN
(A CUSTOM.USERID%TYPE, B CUSTOM.USERNAME%TYPE, C CUSTOM.JUMIN%TYPE,
 D CUSTOM.AGE%TYPE, E CUSTOM.SEX%TYPE, F CUSTOM.ZIP%TYPE, G CUSTOM.ADDR1%TYPE,
 H CUSTOM.ADDR2%TYPE, I CUSTOM.ADDR3%TYPE, J CUSTOM.TEL%TYPE, K CUSTOM.JOB%TYPE,
 L CUSTOM.SCHOL%TYPE, M CUSTOM.POINT%TYPE, N CUSTOM.REGDATE%TYPE)
IS
BEGIN
INSERT INTO CUSTOM VALUES(A, B, C, D, E, F, G, H, I, J, K, L, M, N);
COMMIT;
END;
----------------------------------------------------------------------------
CREATE OR REPLACE PROCEDURE CUS_IN
(A VARCHAR2,B VARCHAR2,C VARCHAR2,D NUMBER,E VARCHAR2,F VARCHAR2,G VARCHAR2,
H VARCHAR2,I VARCHAR2,J VARCHAR2,K VARCHAR2,L VARCHAR2,M NUMBER,N DATE)
IS 
BEGIN 
INSERT INTO CUSTOM VALUES(A,B,C,D,E,F,G,H,I,J,K,L,M,N);
COMMIT;
END;

EXEC CUS_IN('A003', 'INA', '222', 27, '0', '123-123','서울','강남구', '역삼동', '010-1234-5678', '가수', '대졸', 123, SYSDATE);
EXEC CUS_IN('A002', 'INNA', '222', 27, '0', '123-123','서울','강남구', '역삼동', '010-1234-5678', '가수', '대졸', 123, SYSDATE);
EXEC CUS_IN('A001', 'SUZI', '123', 27, '0', '123-123','서울','강남구', '역삼동', '010-1234-5678', '가수', '대졸', 123, SYSDATE);


--CUSTOM 테이블에 UPDATE 시키는 프로시져 (CUS_UP)
--CREATE OR REPLACE PROCEDURE CUS_UP;

CREATE OR REPLACE PROCEDURE CUS_UP
(A VARCHAR2,B VARCHAR2,C VARCHAR2,D NUMBER,E VARCHAR2,F VARCHAR2,G VARCHAR2,
H VARCHAR2,I VARCHAR2,J VARCHAR2,K VARCHAR2,L VARCHAR2,M NUMBER,N DATE)
IS 
BEGIN 
UPDATE CUSTOM SET USERNAME = B, JUMIN = C, AGE = D, SEX = E, ZIP = F,
ADDR1 = G, ADDR2 = H, ADDR3 = I, TEL = J, JOB = K, SCHOL = L, POINT = M,
REGDATE = N
WHERE USERID = A;
COMMIT;
END;

EXEC CUS_UP('A001', 'YUNA', '222', 27, '0', '123-123','서울','강남구', '역삼동', '010-1234-5678', '가수', '대졸', 123, SYSDATE);

 --CUSTOM 테이블에 DELETE 시키는 프로시져 (CUS_DEL)
 --CREATE OR REPLACE PROCEDURE CUS_DEL;
 
CREATE OR REPLACE PROCEDURE CUS_DEL
(A VARCHAR2)
IS 
BEGIN 
DELETE CUSTOM WHERE USERID = A;
COMMIT;
END;

EXEC CUS_DEL('A001');

---함수
SELECT * FROM CUSTOM WHERE USERID = 'A001';

CREATE OR REPLACE FUNCTION F_COBVOL
(GILI IN NUMBER, POK IN NUMBER, NOPI IN NUMBER)
RETURN NUMBER
IS
BUPI NUMBER;
BEGIN
BUPI := GILI*POK*NOPI;
RETURN BUPI;
END;

SELECT F_COBVOL(4, 7, 8) FROM DUAL;

CREATE OR REPLACE FUNCTION F_NAME
(A IN VARCHAR2)
RETURN VARCHAR2
IS
B VARCHAR2(8);
BEGIN
B := SUBSTR(A, -2);
RETURN B;
END;

SELECT USERNAME, F_NAME(USERNAME) NAME FROM CUSTOM WHERE ADDR1 = '제주도';

COL NAME FORMAT A10;
SELECT USERNAME, F_NAME(USERNAME) NAME FROM CUSTOM WHERE ADDR1 = '제주도';

--SELECT 하는 순간에 폭을 맞춰준다


--사용자에게 입력받아서 출력하기
--입사일(REGDATE)를 입력받아 사원명, 입사일, 근무기간(6년 2RODNJF)을 출력

SELECT
FLOOR(MONTHS_BETWEEN(SYSDATE, '1994-10-10')/12) || '년' ||
FLOOR(MOD(MONTHS_BETWEEN(SYSDATE, '1994-10-10'), 12)) || '개월'
FROM DUAL;

CREATE OR REPLACE FUNCTION F_SDAY
(V_DATE IN DATE)
RETURN VARCHAR2
IS
GUNDATE VARCHAR2(20);
BEGIN
GUNDATE :=
FLOOR(MONTHS_BETWEEN(SYSDATE, V_DATE)/12) || '년' ||
FLOOR(MOD(MONTHS_BETWEEN(SYSDATE, V_DATE), 12)) || '개월';
RETURN GUNDATE;
END;

COL GUNDATE FORMAT A10;
SELECT USERNAME, REGDATE, F_SDAY(REGDATE) GUNDATE FROM CUSTOM
WHERE ADDR1 = '제주도';

--주민번호를 입력시 성별 변환 해주는 함수
CREATE OR REPLACE FUNCTION F_GENDER
(V_JUMIN IN VARCHAR2)
RETURN VARCHAR2
IS
GENDER VARCHAR2(4);
BEGIN
GENDER := SUBSTR(V_JUMIN, 8, 1);

--IN 뒤에 SELECT 또는 직접 문자가 올 수도 있음
IF GENDER IN ('1', '3') THEN
 GENDER := '남';
ELSE
 GENDER := '여';

END IF;
 RETURN GENDER;
END;

COL GENDER FORMAT A10;
SELECT USERNAME, JUMIN, F_GENDER(JUMIN) GENDER
FROM CUSTOM WHERE  ADDR1 = '제주도';

--날짜에 년수, 개월수, 날수를 매개변수로 더하는 함수(EX.계약기간)

CREATE OR REPLACE FUNCTION F_GAEYAK
(V_DATE IN DATE, Y IN NUMBER, M IN NUMBER, D IN NUMBER)
RETURN DATE
IS
NALZA DATE;
BEGIN
NALZA := ADD_MONTHS(V_DATE, Y*12);
NALZA := ADD_MONTHS(NALZA, M);
NALZA := NALZA + D;
RETURN NALZA;
END;

SELECT USERNAME, REGDATE, F_GAEYAK(REGDATE, 1, 11, 29) GAEYAK
FROM CUSTOM WHERE ADDR1 = '제주도';
--SHOW ERRORS 몇번째에 오류나는지 확인할때 -CMD

SELECT * FROM CUSTOM;
DESC CUSTOM;

--IF
CREATE OR REPLACE FUNCTION F_PAYGRADE
(V_PAY IN NUMBER)
RETURN VARCHAR2
IS
RESULT VARCHAR2(20);
BEGIN
IF V_PAY > 2500000 THEN
 RESULT := 'A';
ELSIF V_PAY > 2000000 THEN
 RESULT := 'B';
ELSIF V_PAY > 1500000 THEN
 RESULT := 'C';
ELSIF V_PAY > 1000000 THEN
 RESULT := 'D';
ELSE
 RESULT := 'F';
END IF;
 RETURN RESULT;
END;

COL PAYGRADE FORMAT A10;
SELECT USERID, POSIT, PAY, F_PAYGRADE(PAY) || '등급' PAYGRADE
FROM COMPANY WHERE USERID = 'XA9776';

COL PAYGRADE FORMAT A10;
SELECT USERID, POSIT, PAY, F_PAYGRADE(PAY) || '등급' PAYGRADE
FROM COMPANY WHERE USERID = 'ye8802';

SELECT * FROM COMPANY;

--LOOP--자바에서 DO~WHLE문과 같아

CREATE TABLE LOOP1
(NO NUMBER, NAME VARCHAR2(9) DEFAULT '홍길동');

DECLARE
V_COUNT NUMBER(2) := 1;
BEGIN
LOOP
INSERT INTO LOOP1 (NO) VALUES(V_COUNT);
V_COUNT := V_COUNT + 1;
EXIT WHEN V_COUNT > 10;--빠져나와라~~
END LOOP;
DBMS_OUTPUT.PUT_LINE('데이터 입력 완료!!');
END;

SELECT* FROM LOOP1;

--FOR문
CREATE OR REPLACE PROCEDURE P_FOR
IS
BEGIN
FOR I IN 21..30 LOOP
INSERT INTO LOOP1 (NO) VALUES(I);
COMMIT;
END LOOP;
END;

EXEC P_FOR
SELECT * FROM LOOP1;

--WHILE문
CREATE OR REPLACE PROCEDURE BANBOK
(V_LOWER NUMBER, V_UPPER NUMBER) --IN생략
IS
V_COUNTER NUMBER(10) := 0;
V_OUTPUT NUMBER(10) := 0;
BEGIN
V_OUTPUT := V_LOWER;

WHILE V_OUTPUT < V_UPPER LOOP
V_COUNTER := V_COUNTER + 1;
V_OUTPUT := V_OUTPUT + 1;
END LOOP;

DBMS_OUTPUT.PUT_LINE('최종값은 ' || TO_CHAR(V_OUTPUT) ||'이고'||
'총 반복 횟수는 ' || TO_CHAR(V_COUNTER) || '입니다');
END;

EXEC BANBOK(1, 10);

---DO~WHILE
CREATE OR REPLACE PROCEDURE P_CALC1
(V_START NUMBER, V_END NUMBER)
IS
CNT NUMBER := V_START;
TOT NUMBER := 0;
BEGIN
LOOP
TOT := TOT + CNT;
CNT := CNT + 1;
EXIT WHEN CNT > V_END;
END LOOP;
DBMS_OUTPUT.PUT_LINE(TO_CHAR(V_START) ||'부터'|| TO_CHAR(V_END) ||
'까지의 합은 ' ||TO_CHAR(TOT)|| '입니다');
--DBMS_OUTPUT.PUT_LINE(V_START ||'부터'|| V_END ||
--'까지의 합은 ' ||TOT|| '입니다');
END;

EXEC P_CALC1(1, 100);

--WHILE
CREATE OR REPLACE PROCEDURE P_CALC2
(V_START NUMBER, V_END NUMBER)
IS
CNT NUMBER := V_START;
TOT NUMBER := 0;
BEGIN
WHILE CNT <= V_END LOOP
TOT := TOT + CNT;
CNT := CNT + 1;
END LOOP;

DBMS_OUTPUT.PUT_LINE(TO_CHAR(V_START) ||'부터'|| TO_CHAR(V_END) ||
'까지의 합은 ' ||TO_CHAR(TOT)|| '입니다');
END;

EXEC P_CALC2(1, 100);

--FOR
CREATE OR REPLACE PROCEDURE P_CALC3
(V_START NUMBER, V_END NUMBER)
IS

TOT NUMBER := 0;
BEGIN
FOR I IN V_START..V_END LOOP
TOT := TOT + I;
END LOOP;

DBMS_OUTPUT.PUT_LINE(TO_CHAR(V_START) ||'부터'|| TO_CHAR(V_END) ||
'까지의 합은 ' ||TO_CHAR(TOT)|| '입니다');
END;

EXEC P_CALC3(1, 100);

--예외처리
CREATE OR REPLACE PROCEDURE EXE_TEST
IS
SW_REC 사원%ROWTYPE;
BEGIN
SELECT * INTO SW_REC FROM 사원;
DBMS_OUTPUT.PUT_LINE('데이터 검색 성공!!');
EXCEPTION
WHEN TOO_MANY_ROWS THEN
ROLLBACK;
DBMS_OUTPUT.PUT_LINE('데이터가 많습니다!');

WHEN NO_DATA_FOUND THEN
ROLLBACK;
DBMS_OUTPUT.PUT_LINE('데이터가 없습니다!');

WHEN OTHERS THEN
ROLLBACK;
DBMS_OUTPUT.PUT_LINE('기타 오류입니다!');

END;

EXEC EXE_TEST;

CREATE OR REPLACE PROCEDURE EXE_TEST
IS
SW_REC 사원%ROWTYPE;
BEGIN
SELECT * INTO SW_REC FROM 사원 WHERE 사원번호 = '2000';
DBMS_OUTPUT.PUT_LINE('데이터 검색 성공!!');
EXCEPTION
WHEN TOO_MANY_ROWS THEN
ROLLBACK;
DBMS_OUTPUT.PUT_LINE('데이터가 많습니다!');

WHEN NO_DATA_FOUND THEN
ROLLBACK;
DBMS_OUTPUT.PUT_LINE('데이터가 없습니다!');

WHEN OTHERS THEN
ROLLBACK;
DBMS_OUTPUT.PUT_LINE('기타 오류입니다!');

END;


-----------2021.02.04.금-------------PL/SQL마지막날

CREATE TABLE EMP2
(EMPNO NUMBER(4) PRIMARY KEY,
ENAME VARCHAR2(10),
DEPTNO NUMBER(2));

INSERT INTO EMP2 VALUES (1001, 'SUZI', 10);
INSERT INTO EMP2 VALUES (1002, 'INNA', 20);

COMMIT;

CREATE OR REPLACE PROCEDURE IN_EMP2
(EMPNO IN NUMBER, DEPTNO IN NUMBER)
IS
NAME VARCHAR2(10) := '미지정';
BEGIN
INSERT INTO EMP2 VALUES (EMPNO, NAME, DEPTNO);
COMMIT;

EXCEPTION
WHEN DUP_VAL_ON_INDEX THEN
DBMS_OUTPUT.PUT_LINE('데이터 중복!!');
END;

EXEC IN_EMP2(1003, 30);
SELECT * FROM EMP2;

SET SERVEOUTPUT ON
EXEC IN_EMP2(1003, 30);

--사용자 정의 에러
CREATE OR REPLACE PROCEDURE PAY_GRADE--DROP PROCEDURE로 지울수 있음
(V_SANO 사원.사원번호%TYPE)
IS
NOT_ENOUGH_PAY EXCEPTION;
SW_REC 사원%ROWTYPE;
BEGIN
SELECT * INTO SW_REC FROM 사원 WHERE 사원번호 = V_SANO;

IF SW_REC.급여 >= 3000 THEN
DBMS_OUTPUT.PUT_LINE('급여가 3000이상 적당함!');

ELSIF SW_REC.급여 < 3000 THEN
RAISE NOT_ENOUGH_PAY;--에러 발생시킴

ELSE
DBMS_OUTPUT.PUT_LINE('급여가 적당하지 않음!');
END IF;

EXCEPTION
WHEN NOT_ENOUGH_PAY THEN
RAISE_APPLICATION_ERROR(-20001,'급여가 충분하지 못함');
END;

EXEC PAY_GRADE(2001);
--CURSOR

CREATE OR REPLACE PROCEDURE P_DEPTNO
(I_DEPTNO 사원.부서번호%TYPE)
IS
    CURSOR CUR_DEPTNO--CUR_DEPTNO 내가 지정한 이름임
    IS
    --여기에 어떤 SELECT문을 써도 상관X
    SELECT 부서번호, 사원명, 직급, 급여 FROM 사원
    WHERE 부서번호 = I_DEPTNO;
  
  V_DEPTNO 사원.부서번호%TYPE;
  V_SANAME 사원.사원명%TYPE;
  V_JIK 사원.직급%TYPE;
  V_SAL 사원.급여%TYPE;
  
 BEGIN
  
 OPEN CUR_DEPTNO;--OPEN과 CLOSE가 짝임
  
 DBMS_OUTPUT.PUT_LINE('부서번호     사원명     직급     급여');
 DBMS_OUTPUT.PUT_LINE('-------------------------------------');
  
 LOOP --반복문
 --가져오는 작업을 FETCH
 FETCH CUR_DEPTNO INTO V_DEPTNO, V_SANAME, V_JIK, V_SAL;
 --언제 빠져나갈 것인지 조건문 쓰자
 EXIT WHEN CUR_DEPTNO%NOTFOUND;--커서에 시스템 변수.커서가 오픈되어있을 때 사용가능
 --데이터가 있는지 없는지 판단해줌
 --커서에 더이상 데이터가 없으면 빠져나옴
  
 DBMS_OUTPUT.PUT_LINE(TO_CHAR(V_DEPTNO) ||'  '||
 V_SANAME ||'  '|| V_JIK ||'  '|| TO_CHAR(V_SAL));
  
 END LOOP;
 
 DBMS_OUTPUT.PUT_LINE('-------------------------------------');
 DBMS_OUTPUT.PUT_LINE('전체 데이터 갯수: ' || TO_CHAR(CUR_DEPTNO%ROWCOUNT)); --ROWCOUNT도 커서가 오픈되어있을 때 사용가능
 
 CLOSE CUR_DEPTNO;
 
 END;
 
 
 --FOR문을 쓰면 OPEN, CLOSE, FETCH 쓰는 것 신경 안써도 ?
 
 --FOR문으로 다시만들기
 
 EXEC P_DEPTNO(20);
 
CREATE OR REPLACE PROCEDURE P_DEPTNO
(I_DEPTNO 사원.부서번호%TYPE)
IS
    CURSOR CUR_DEPTNO--CUR_DEPTNO 내가 지정한 이름임
    IS
    --여기에 어떤 SELECT문을 써도 상관X
    SELECT 부서번호, 사원명, 직급, 급여 FROM 사원
    WHERE 부서번호 = I_DEPTNO;
V_CNT NUMBER;--전역변수
BEGIN
DBMS_OUTPUT.PUT_LINE('부서번호     사원명     직급     급여');
DBMS_OUTPUT.PUT_LINE('-------------------------------------');
--반복문
--FOR CURDEPT IN 1..5
FOR CURDEPT IN CUR_DEPTNO--커서에 있는 것을 하나를 꺼내서 여기에 넣어라
--FOR문이 자동으로 OPEN/FETCH 함
LOOP 
DBMS_OUTPUT.PUT_LINE(TO_CHAR(CURDEPT.부서번호) ||'  '||
CURDEPT.사원명 ||'  '|| CURDEPT.직급 ||'  '|| TO_CHAR(CURDEPT.급여));
--FOR문이 닫히기 전에 이걸 집어넣어야지 FOR문이 끝나면 사용할 수 없게 만든다
V_CNT := CUR_DEPTNO%ROWCOUNT;
END LOOP;
DBMS_OUTPUT.PUT_LINE('-------------------------------------');
DBMS_OUTPUT.PUT_LINE('전체 데이터 갯수: ' || TO_CHAR(V_CNT));
END;


--사원번호(USERID)를 입력시 사원이름과 구입한 제품명을 출력-JOIN문

CREATE OR REPLACE PROCEDURE P_JEPUM
(V_USERID CUSTOM.USERID%TYPE)
IS

V_CNT NUMBER;

   CURSOR SA_CUR
   IS
   SELECT C.USERID, C.USERNAME, S.PRODUCTNAME
   FROM CUSTOM C, SALES S 
   WHERE C.USERID = S.USERID AND S.USERID = V_USERID;
   
BEGIN

DBMS_OUTPUT.PUT_LINE('아이디  이름  제품명');
DBMS_OUTPUT.PUT_LINE('-------------------------------------');

FOR I IN SA_CUR

LOOP
DBMS_OUTPUT.PUT_LINE(I.USERID ||'  '|| I.USERNAME||''|| I.PRODUCTNAME);

V_CNT := SA_CUR%ROWCOUNT;

END LOOP;

DBMS_OUTPUT.PUT_LINE('전체데이터 갯수:'  || TO_CHAR(V_CNT));
END;

EXEC P_JEPUM('ge8720');
EXEC P_JEPUM('ai6542');

--PACKAGE
 CREATE OR REPLACE PACKAGE SAWON_PACK
 IS
 PROCEDURE SANO_OUT;--프로시져를 여러개로 모아둔다
 PROCEDURE SANAME_OUT;
 PROCEDURE BUNO_OUT;
 PROCEDURE JIK_OUT;
 END SAWON_PACK;
 
 --BODY 부분 만들기 - 전체적인 커서 부분을 만든다
 --프로시져 4개를 만든다
 
 CREATE OR REPLACE PACKAGE BODY SAWON_PACK--이름같아야?
 IS
	 CURSOR SW_CUR
	 IS
	 SELECT * FROM 사원;
 
 PROCEDURE SANO_OUT
 IS
 BEGIN
 DBMS_OUTPUT.PUT_LINE('사원번호');
 DBMS_OUTPUT.PUT_LINE('--------');
 
 FOR K IN SW_CUR LOOP
  DBMS_OUTPUT.PUT_LINE(K.사원번호);
 
 END LOOP;
 END;
 
 PROCEDURE SANAME_OUT
 IS
 BEGIN
 DBMS_OUTPUT.PUT_LINE('사원명');
 DBMS_OUTPUT.PUT_LINE('------');
 
 FOR K IN SW_CUR LOOP
  DBMS_OUTPUT.PUT_LINE(K.사원명);
 
 END LOOP;
 END;
 
 PROCEDURE BUNO_OUT
 IS
 BEGIN
 DBMS_OUTPUT.PUT_LINE('부서번호');
 DBMS_OUTPUT.PUT_LINE('--------');
 
 FOR K IN SW_CUR LOOP
  DBMS_OUTPUT.PUT_LINE(K.부서번호);
 
 END LOOP;
 END;
 
 PROCEDURE JIK_OUT
 IS
 BEGIN
 DBMS_OUTPUT.PUT_LINE('직급');
 DBMS_OUTPUT.PUT_LINE('----');
 
 FOR K IN SW_CUR LOOP
  DBMS_OUTPUT.PUT_LINE(K.직급);
 
 END LOOP;
 END;
 
 END;
 
 --TRIGGER 방아쇠(연쇄반응)
-- AFTER, BEFORE TRIGGER 두 종류가 있어
DROP TABLE HAKSANG;
DROP TABLE MEMO;
DROP TABLE MEMP;

CREATE TABLE HAKSANG
(HAKBUN VARCHAR2(10), NAME VARCHAR2(10));

CREATE TABLE MEMO
(NO NUMBER, BIGO VARCHAR2(200));

CREATE SEQUENCE SE100
START WITH 1
INCREMENT BY 1
MAXVALUE 100
NOCYCLE;

--AFTER TRIGGER = INSERT TRIGGER :데이터를 INSERT 할 때 사용
CREATE OR REPLACE TRIGGER TRI_HAKSANG_IN
AFTER INSERT
ON LEE.HAKSANG--LEE가 가지고 있는 HAKSANG에 실행해라
BEGIN
INSERT INTO MEMO VALUES(SE100.NEXTVAL, '행이 INSERT되었습니다.');
END;

INSERT INTO HAKSANG VALUES(111, 'SUZI');
SELECT * FROM HAKSANG;
SELECT * FROM MEMO;

COL BIGO FORMAT A30;

CREATE OR REPLACE TRIGGER TRI_HAKSANG_IN
AFTER INSERT
ON LEE.HAKSANG--LEE가 가지고 있는 HAKSANG에 실행해라
FOR EACH ROW
BEGIN
INSERT INTO MEMO VALUES(SE100.NEXTVAL, :NEW.NAME ||'행이 INSERT되었습니다.');
END;

INSERT INTO HAKSANG VALUES(222, 'INNA');

--입력한 데이터 복사해서 다른 테이블에 넣기

DROP TABLE COPY_HAKSANG;
CREATE TABLE COPY_HAKSANG
(HAKBUN VARCHAR2(100),NAME VARCHAR2(100));

CREATE OR REPLACE TRIGGER TRI_COPY_HAKSANG_IN
AFTER INSERT
ON LEE.HAKSANG--LEE가 가지고 있는 HAKSANG에 실행해라
FOR EACH ROW
BEGIN
INSERT INTO COPY_HAKSANG VALUES(:NEW.HAKBUN, :NEW.NAME);
END;

INSERT INTO HAKSANG VALUES(333, 'INSUN');
--DELETE INTO HAKSANG VALUES(333, 'INSUN');
COMMIT;

CREATE OR REPLACE TRIGGER TRI_HAKSANG_UP
AFTER UPDATE
ON LEE.HAKSANG--트리거를 만들때 스키마 꼭 쓰기
FOR EACH ROW
BEGIN
INSERT INTO MEMO VALUES(SE100.NEXTVAL, :OLD.NAME || '행이' ||
:NEW.NAME ||'으로 UPDATE 되었습니다.');
END;

UPDATE HAKSANG SET NAME = 'AGELINA' WHERE HAKBUN = 111;

--AFTER TRIGGER : DELETE TRIGGER
CREATE OR REPLACE TRIGGER TRI_HAKSANG_DEL
AFTER DELETE
ON LEE.HAKSANG
FOR EACH ROW
BEGIN
 INSERT INTO MEMO VALUES(SE100.NEXTVAL, :OLD.NAME || '행이 DELETE 되었습니다.');
 INSERT INTO LEE.COPY_HAKSANG VALUES(:OLD.HAKBUN, :OLD.NAME);
 
END;

DELETE HAKSANG WHERE HAKBUN = 111;
 
SELECT*FROM HAKSANG;
SELECT*FROM MEMO;
SELECT*FROM COPY_HAKSANG;

--BEFORE TRIGGER (토, 일, 12-7시 이외에 DML 금지)

CREATE TABLE INSA
(EMPNO NUMBER(4) PRIMARY KEY, ENAME VARCHAR2(10),
JIK VARCHAR2(10), SAL NUMBER);

CREATE OR REPLACE TRIGGER TRI_INSA
BEFORE INSERT OR DELETE OR UPDATE
ON LEE.INSA
--이상이 있으면 HOLDING시켜. 없으면 밑에 그냥 실행시켜
DECLARE

IMPOSSIBLE_TIME EXCEPTION;

BEGIN
IF TO_CHAR(SYSDATE, 'DAY') IN ('토요일', '일요일') OR
TO_CHAR(SYSDATE, 'HH24') <12 OR TO_CHAR(SYSDATE, 'HH24') >16
... --분을 안가져와서. =17 THEN
RAISE IMPOSSIBLE_TIME;
END IF;

EXCEPTION
WHEN IMPOSSIBLE_TIME THEN
RAISE_APPLICATION_ERROR(-20007, '월요일부터 금요일까지 정오 12:00 부터 오후 5시까지만 DML 작업이 가능합니다.');
END;

INSERT INTO INSA VALUES(1, '배수지', '가수', 5000);
COMMIT;

SELECT * FROM INSA;

--시간설정에서 바꿔서 다시 INSERT 해보자: ERROR 난다

--주민번호 검사
CREATE TABLE MEMBER
(ID NUMBER(3) PRIMARY KEY, NAME VARCHAR(10), JUBUN VARCHAR(13));

CREATE OR REPLACE TRIGGER TRI_MEMBER_JUBUN
BEFORE INSERT OR UPDATE OF JUBUN
--하나만 써도 ?
ON LEE.MEMBER
FOR EACH ROW

DECLARE
A NUMBER;
B NUMBER;
C NUMBER;
D NUMBER;
E NUMBER;
F NUMBER;
G NUMBER;
H NUMBER;
I NUMBER;
J NUMBER;
K NUMBER;
L NUMBER;
M NUMBER;

CK NUMBER;
JUBUNFAIL EXCEPTION;
BEGIN
A := SUBSTR(:NEW.JUBUN, 1, 1);
B := SUBSTR(:NEW.JUBUN, 2, 1);
C := SUBSTR(:NEW.JUBUN, 3, 1);
D := SUBSTR(:NEW.JUBUN, 4, 1);
E := SUBSTR(:NEW.JUBUN, 5, 1);
F := SUBSTR(:NEW.JUBUN, 6, 1);
G := SUBSTR(:NEW.JUBUN, 7, 1);
H := SUBSTR(:NEW.JUBUN, 8, 1);
I := SUBSTR(:NEW.JUBUN, 9, 1);
J := SUBSTR(:NEW.JUBUN, 10, 1);
K := SUBSTR(:NEW.JUBUN, 11, 1);
L := SUBSTR(:NEW.JUBUN, 12, 1);
M := SUBSTR(:NEW.JUBUN, 13, 1);

CK := (A*2)+(B*3)+(C*4)+(D*5)+(E*6)+(F*7)+(G*8)+(H*9)+(I*2)+(J*3)+(K*4)+(L*5);
 
CK := MOD(CK, 11);
CK := 11-CK;
CK := MOD(CK, 10);

IF M != CK THEN
RAISE JUBUNFAIL;
END IF;

EXCEPTION
WHEN JUBUNFAIL THEN
RAISE_APPLICATION_ERROR(-20001, '주민번호가 틀렸습니다!');
END;

INSERT INTO MEMBER VALUES (10, 'SUZI', '970612123597');
INSERT INTO MEMBER VALUES (20, 'INNA', '970614215429');
COMMIT;


---시스템
 drop user SUZI cascade;
 
CREATE USER suzi
IDENTIFIED by a123
DEFAULT TABLESPACE USERS TEMPORARY TABLESPACE TEMP;
 
GRANT CONNECT, RESOURCE, UNLIMITED TABLESPACE TO suzi;


CONN suzi/a123

CREATE TABLE SCORE
(HAK VARCHAR2(10) PRIMARY KEY,
NAME VARCHAR2(20) NOT NULL,
KOR NUMBER(3),
ENG NUMBER(3),
MAT NUMBER(3));

INSERT INTO SCORE VALUES (111, '배수지', 30, 40, 50);
INSERT INTO SCORE VALUES (222, '유인나', 70, 90, 60);
INSERT INTO SCORE VALUES (333, '정인선', 80, 40, 58);
COMMIT;

SELECT*FROM SCORE;
