select * from tab; --코드 옆에서 ctrl + ENTER 치면 data가 아래에 나옴
--한줄주석
/* 여러주석*/
select * from CUSTOM;

SELECT * FROM COMPANY;

SELECT USERID, PAY, ROUND (PAY, -4) PAY FROM COMPANY;

select * from CUSTOM;

--주민번호 * 표시 만들기 :970614-2******
SELECT RPAD(SUBSTR(JUMIN, 1, 8), 14, '*') JUMIN FROM CUSTOM;

SELECT COUNT(*) INWON FROM CUSTOM WHERE JOB = '회사원';

SELECT COUNT(*) INWON FROM CUSTOM WHERE ADDR1 LIKE '서울%';

SELECT COUNT(*) INWON FROM CUSTOM WHERE POINT >= 200;

SELECT * FROM COMPANY;--TABLE의 이름과 COLUMN의 이름이 중복되면 잘못된 것이다. 하면 안된다

--대리가 받는 총금액
SELECT COUNT(PAY) FROM COMPANY WHERE POSIT = '대리';
--SUM: 합계
SELECT SUM(PAY) FROM COMPANY WHERE POSIT = '대리';

SELECT * FROM CUSTOM;

--직업별 인원수
SELECT JOB, COUNT(*) INWON FROM CUSTOM GROUP BY JOB;

--학력별 POINT의 평균
SELECT SCHOL, ROUND(AVG(POINT)) INWON FROM CUSTOM GROUP BY SCHOL;

--지역별 POINT의 합계
SELECT ADDR1, ROUND(SUM(POINT)) INWON FROM CUSTOM GROUP BY ADDR1;

SELECT ADDR1, ROUND(SUM(POINT)) INWON, MAX(POINT)"MAX", MIN(POINT) "MIN" FROM CUSTOM GROUP BY ADDR1;


-- 성별 나이의 평균 인원수
SELECT SEX, ROUND(AVG(AGE)) "AVG", COUNT(*) "CNT" FROM CUSTOM GROUP BY SEX;

SELECT CASE SEX WHEN '1' THEN '남자' WHEN '0' THEN '여자'
END GENDER, ROUND(AVG(AGE)) "AVG", COUNT(*) "CNT" FROM CUSTOM GROUP BY SEX;
/*
SELECT 
CASE 컬럼명                         
	WHEN 1 THEN 100,                          
	WHEN 2 THEN 200,                         
	WHEN 3 THEN 300,                         
	WHEN 4 THEN 400                          
	ELSE 500                        
END AS RESULT(RESULT->파생 컬럼명)            
FROM DUAL;
*/

--하나일 때는 WHEN 1 THEN 100  ELSE 0 처럼 쓴다

SELECT*FROM COMPANY;
--직책별 전체 월급의 합계, 평균, MAX, MIN
SELECT POSIT, COUNT(*) CNT, ROUND(AVG(PAY)) 평균, MAX(PAY) 최대,
MIN(PAY) 최소 FROM COMPANY GROUP BY POSIT;

HAVING CNT > 60; --  COUNT(*)실제 데이터를 복숩.*표시 바꿀수 없음.*칭 사용못함.

------2021.01.25.화-------------

select A, B, D, A, E, F FROM AA(TABLE NAME), BB(T.N)
WHERE AA.A = BB.A -->이게 JOIN. 내가 가져오자하는 데이터를 가져오는 것

--select A, B, D, A, E, F FROM AA(TABLE NAME), BB(T.N) ->분자
--WHERE AA.A = BB.A ->분모

--JOIN
SELECT CUSTOM.USERID, USERNAME, ADDR1, COMPANY.USERID, DEPT, POSIT, PAY
FROM CUSTOM, COMPANY
WHERE CUSTOM.USERID = COMPANY.USERID;

--오라클 SQL EQUI JOIN(이제는 거의 둘다 쓰임)
SELECT A.USERID, USERNAME, ADDR1, B.USERID, DEPT, POSIT, PAY
FROM CUSTOM A, COMPANY B
WHERE A.USERID = B.USERID;

/*
EQUI JOIN(INNER JOIN) --가장 많이 사용
NON-EQUI JOIN -오라클에만 있는 JOIN.거의 사용안함
OUTER JOIN-거의 사용안함
CROSS JOIN-거의 사용안함
SELF JOIN-알아야?
*/

--ANSI 표준 SQL :INNER JOIN-여러가지 테이블 비교할때
SELECT A.USERID, USERNAME, ADDR1, B.USERID, DEPT, POSIT, PAY
FROM CUSTOM A INNER JOIN COMPANY B
ON A.USERID = B.USERID;--동등JOIN
--JOIN 조건문은 ON

--테이블 CUSTOM에서  USERID, USERNAME 검색 후
--POINT 테이블에서 제품 구입, 로그인 관계된 POIN점수(PRODUCT, LOGIN)검색

SELECT * FROM POINT;
SELECT A.USERID, USERNAME, PRODUCT, LOGIN
FROM CUSTOM A, POINT B
WHERE A.USERID = B.USERID AND LOGIN;

SELECT A.USERID, USERNAME, PRODUCT, LOGIN
FROM CUSTOM A, POINT B
WHERE A.USERID = B.USERID AND LOGIN;

--도구-쿼리설정-모든 데이터 FETCH하면 실핼 할 때마다 모든 데이터 출력

SELECT * FROM POINT;
SELECT A.USERID, USERNAME, PRODUCT, LOGIN
FROM CUSTOM A, POINT B
WHERE A.USERID = B.USERID AND LOGIN >= 10;

SELECT * FROM POINT;
SELECT A.USERID, USERNAME, PRODUCT, LOGIN
FROM CUSTOM A INNER JOIN POINT B
WHERE A.USERID = B.USERID AND LOGIN;

--OUTER JOIN
--특정 테이블이 기준이 되어서 데이터를 찾아옴

SELECT COUNT(*) FROM CUSTOM; --459
--(원래는 COMPANY보다 데이타수가 많아야되지만
--오류로 인해 데이터가 덜들어간 상태)

SELECT COUNT(*) FROM COMPANY; --464

SELECT A.USERID, USERNAME, ADDR1, COMPANY, DEPT
FROM CUSTOM A, COMPANY B
WHERE A.USERID = B.USERID;

--기본은 INNER JOIN
--459데이타인 CUSTOM을 기준으로 두면,
SELECT A.USERID, USERNAME, ADDR1, COMPANY, DEPT
FROM CUSTOM A, COMPANY B
WHERE A.USERID = B.USERID(+);--A를 기준

SELECT A.USERID, USERNAME, ADDR1, COMPANY, DEPT
FROM CUSTOM A, COMPANY B
WHERE A.USERID(+)= B.USERID;--B로 기준

SELECT A.USERID, USERNAME, ADDR1, COMPANY, DEPT
FROM CUSTOM A LEFT OUTER JOIN COMPANY B--왼쪽인 CUSTOM이 기준일때
ON A.USERID = B.USERID;

SELECT A.USERID, USERNAME, ADDR1, COMPANY, DEPT
FROM CUSTOM A RIGHT OUTER JOIN COMPANY B
ON A.USERID = B.USERID;

SELECT * FROM research;
SELECT COUNT(*) FROM RESEARCH;

SELECT A.USERID, USERNAME, ANSWER
FROM CUSTOM A, RESEARCH B
WHERE A.USERID = B.USERID(+);--A로 기준

SELECT A.USERID, USERNAME, ANSWER
FROM CUSTOM A LEFT OUTER JOIN RESEARCH B
ON A.USERID = B.USERID;

--ANSWER을 안한 사람만 찾기
SELECT A.USERID, USERNAME, ANSWER
FROM CUSTOM A, RESEARCH B
WHERE A.USERID = B.USERID(+) AND ANSWER IS NULL;

SELECT A.USERID, USERNAME, ANSWER
FROM CUSTOM A LEFT OUTER JOIN RESEARCH B
ON A.USERID = B.USERID
WHERE ANSWER IS NULL;

--CROSS JOIN(상호조인)
SELECT COUNT(*) FROM CUSTOM;--459
SELECT COUNT(*) FROM COMPANY;--464

--INNER JOIN
SELECT A.USERID, USERNAME, ADDR1, COMPANY, DEPT
FROM CUSTOM A, COMPANY B;
--WHERE A.USERID = B.USERID;

--SELF JOIN : 2가지 방법 KIM과 LEE에서 하는 방법 알아보자
SELECT * FROM CUSTOM;

DESC CUSTOM;

--제약조건 중 중복값이 들어가면 안되는 UNIQUE라는 제약조건 있음
--이것을 USERNAME에 넣는다는 가정하면(보통은 USERNAME에 안씀)
--이렇게 검사하는 것을 SELF JOIN
SELECT A.*
FROM CUSTOM A, CUSTOM B
WHERE A.USERNAME = B.USERNAME
ORDER BY A.USERNAME;
--스스로 컬럼 여러개를 하나로 묶어서 JOIN으로 만든다->SELF JOIN

SELECT A.*
FROM CUSTOM A, CUSTOM B
WHERE A.USERNAME = B.USERNAME
AND A.USERID<>B.USERID
ORDER BY A.USERNAME;

--동명 3인 같은 경우
SELECT DISTINCT A.*
FROM CUSTOM A, CUSTOM B
WHERE A.USERNAME = B.USERNAME
AND A.USERID<>B.USERID
ORDER BY A.USERNAME;
--AND A.USERID<>B.USERID
--: 지금은 괜찮지만 나중에 데이터가 여러개 섞일 경우
--꼭 기본적으로 쓰임. 꼭 쓰기!! 문법.
--AND A.USERID<>B.USERID을 사용했을 때 동명이인만 출력

--CUSTOM TABLE에 '제주도'에 살고 있는 사람 중 동일 이름 갖는 행 검색
SELECT * FROM CUSTOM WHERE ADDR1 = '제주도';

SELECT DISTINCT A.*
FROM CUSTOM A, CUSTOM B
WHERE A.ADDR1 = '제주도'
AND A.USERNAME = B.USERNAME
AND A.USERID<>B.USERID
AND A.ADDR1 = B.ADDR1
ORDER BY A.USERNAME;

SELECT A.*
FROM CUSTOM A INNER JOIN CUSTOM B
ON A.USERNAME = B.USERNAME 
WHERE A.USERID<>B.USERID AND A.ADDR1 = '제주도' AND B.ADDR1 = '제주도'
ORDER BY A.USERNAME;

--3개이상의 table join
SELECT A.USERID, USERNAME, COMPANY, DEPT, PRODUCT, LOGIN
FROM CUSTOM A, COMPANY B, POINT C
WHERE A.USERID = B.USERID AND A.USERID = C.USERID;
--반드시 USERID 사용하기에 이러한 구조로 작성

--ANSI 표준
SELECT A.USERID, USERNAME, COMPANY, DEPT, PRODUCT, LOGIN
FROM CUSTOM A INNER JOIN COMPANY B
ON A.USERID = B.USERID INNER JOIN POINT C
ON A.USERID = C.USERID;

--UNION/ALL

SELECT* FROM CUSTOM;
--모든 데이터를 하나에 넣어놓은 것을 이제 나눠볼 것.

CREATE TABLE JEJU
AS
SELECT * FROM CUSTOM WHERE ADDR1 = '제주도';

CREATE TABLE KYUNG
AS SELECT * FROM CUSTOM WHERE ADDR1 = '경기도';

CREATE TABLE SEOUL
AS SELECT * FROM CUSTOM WHERE ADDR1 = '서울특별시';

----------------------------------------------------
--아래 코드로는 TABLE이 다르기 때문에 분류된 것이 아니라
--다른 TABLE을 각 각 출력하는 것
SELECT * FROM JEJU;
SELECT * FROM KYUNG;
SELECT * FROM SEOUL;

--아래코드로 하면 각 테이블이 섞여서 전체가 출력?
--왼쪽 USERID를 보면 정렬되어있는 것을 볼 수 있음
--그 이유는 PRIMARY KEY로 정렬된 것.
--나중에 PRIMARY KEY를 배울 때 알게?

SELECT * FROM JEJU
UNION
SELECT * FROM KYUNG
UNION
SELECT * FROM SEOUL;

--DROP TABLE SEOUL; --테이블 지울때

--SUB QUERY(하위쿼리):쿼리 안에 쿼리 넣기

--COMPANY 테이블에서 USERID, COMPANY, DEPT, PAY와 평균 월급 검색
SELECT USERID, COMPANY, DEPT, PAY, AVG(PAY) FROM COMPANY;--ERROR
--AVE(PAY)->단일값
SELECT ROUND(AVG(PAY)) FROM COMPANY;--1782888

SELECT USERID, COMPANY, DEPT, PAY, 1782888 AVG_PAY FROM COMPANY;

--쿼리 안에 쿼리 넣기
SELECT USERID, COMPANY, DEPT, PAY,
(SELECT ROUND(AVG(PAY)) FROM COMPANY) AVG_PAY--가로로 완전히 묶어서
FROM COMPANY;

--연산도 가능
SELECT USERID, COMPANY, DEPT, PAY,
PAY - (SELECT ROUND(AVG(PAY)) FROM COMPANY) AVG_PAY--가로로 완전히 묶어서
FROM COMPANY;

--CUSTOM 테이블에서 평균 나이 이상이 행들 검색
SELECT * FROM CUSTOM;

SELECT ROUND(AVG(AGE)) FROM CUSTOM;

SELECT*FROM CUSTOM WHERE AGE >= (SELECT AVG(AGE) FROM CUSTOM);
--테이블이 같아야?

--COMPANY 테이블에서 평균 월급보다 적은 월급을 받는 행 검색
SELECT ROUND(AVG(PAY)) FROM COMPANY;--1782888
SELECT * FROM COMPANY WHERE PAY < (SELECT AVG(PAY) FROM COMPANY);


--'현대 자동차' 회사에 근무하는 고객의 USERID, USERNAME, ADDR1, SCHOL 열 검색
SELECT*FROM COMPANY WHERE COMPANY LIKE '현대자동차%';

SELECT * FROM CUSTOM
WHERE USERID = 'EE9224' OR USERID = 'el3409';

SELECT * FROM CUSTOM
WHERE USERID IN('EE9224','el3409');

SELECT * FROM CUSTOM
WHERE USERID IN (SELECT USERID FROM COMPANY WHERE COMPANY LIKE '현대자동차%');

SELECT * FROM COMPANY;
--JOIN

SELECT A.USERID, USERNAME, ADDR1, SCHOL, COMPANY
FROM CUSTOM A, COMPANY B
WHERE A.USERID = B.USERID
AND COMPANY LIKE '현대자동차%';

SELECT A.*, B.COMPANY
FROM CUSTOM A, COMPANY B
WHERE A.USERID = B.USERID
AND COMPANY LIKE '현대자동차%';

--SALSES 테이블에서 4회 이상 판매기록이 있는 고객들의 기본정도 검색
SELECT * FROM SALES
ORDER BY USERID;--물건구매 횟수 확인가능

SELECT USERID--, COUNT(*) CNT->4회이상 판매 다나옴
FROM SALES
GROUP BY USERID
HAVING COUNT(*) >= 4;--별칭(내가 이름 못지음) 못씀

--하위쿼리
SELECT USERID FROM CUSTOM
WHERE USERID IN
(SELECT USERID FROM SALES
GROUP BY USERID
HAVING COUNT(*) >= 4);

--INLINE VIEW -안에 가상 데이타 있음
SELECT A.*
FROM ()A, ()B;

SELECT A.*, CNT
FROM CUSTOM A, --CUSTOM 자리에도 ()가상 데이터 넣을 수 있음
--기존의 데이타를 다른 테이블과 연관지어 만드는 사람이 쿼리 잘함...^^7
(SELECT USERID, COUNT(*) CNT FROM SALES GROUP BY USERID HAVING COUNT(*) >= 4) B
--(물건 4회이상 구입 정보)가상의 데이타여서
--테이블에는 AS 쓰면 안?
WHERE A.USERID = B.USERID;

SELECT A.*, CNT
FROM CUSTOM A, 
(SELECT USERID, COUNT(*) CNT FROM SALES
GROUP BY USERID) B
WHERE A.USERID = B.USERID AND CNT >=4;

--총 판매 금액이 100만원 이상인 CUSTOM 테이블에는 고객의 기본 정보

SELECT * FROM SALES;


--JOIN
SELECT A.*, CNT, HAP--CUSTOM
FROM CUSTOM A, 
(SELECT USERID , COUNT(*) CNT, SUM(PRICE) HAP FROM SALES
GROUP BY USERID
HAVING SUM(PRICE) >= 1000000) B
WHERE A.USERID = B.USERID;

SELECT USERID FROM SALES GROUP BY USERID HAVING SUM(PRICE) >= 1000000;

SELECT USERID, COMPANY, DEPT, PAY,
(SELECT ROUND(AVG(PAY)) FROM COMPANY) AVG_PAY--가로로 완전히 묶어서
FROM COMPANY;

--하위쿼리
SELECT * FROM CUSTOM
WHERE USERID IN
(SELECT USERID FROM SALES GROUP BY USERID HAVING SUM(PRICE) >= 1000000);

--ANY, ALL
--ANY 무조건 범위값 포함 = 최소값 보다 크다 >ANY. 
--ALL 범위값 포함 X = 최대값 보다 작다

SELECT POINT FROM CUSTOM
WHERE ADDR1 = '제주도'
ORDER BY POINT;
--가장 작은값 : 132(최소값)
--가장 큰 값 : 269(최대값)

/*
132 ~ 269
>ANY : 132보다 큰데이터
<ANY :269보다 작은 데이터
<ALL : 269보다 큰 데이터
>ALL : 132보다 작은 데이터
*/

SELECT USERID, USERNAME, POINT FROM CUSTOM
WHERE POINT > ANY (SELECT POINT FROM CUSTOM WHERE ADDR1 = '제주도');
--위 코드가 아래보다 훨씬 데이타 속도가 빠르다
--MS-SQL
SELECT USERID, USERNAME, POINT FROM CUSTOM
WHERE POINT > ANY (SELECT MIN(POINT) FROM CUSTOM WHERE ADDR1 = '제주도');

SELECT USERID, USERNAME, POINT FROM CUSTOM
WHERE POINT < (SELECT MAX(POINT) FROM CUSTOM WHERE ADDR1 = '제주도');
-------------------------------------------------------------------------
SELECT USERID, USERNAME, POINT FROM CUSTOM
WHERE POINT > ALL (SELECT POINT FROM CUSTOM WHERE ADDR1 = '제주도');

SELECT USERID, USERNAME, POINT FROM CUSTOM
WHERE POINT > (SELECT MAX(POINT) FROM CUSTOM WHERE ADDR1 = '제주도');
--------------------------------------------------------------------------
SELECT USERID, USERNAME, POINT FROM CUSTOM
WHERE POINT < (SELECT MIN(POINT) FROM CUSTOM WHERE ADDR1 = '제주도');--안?

SELECT * FROM CUSTOM
WHERE POINT = 131;

SELECT * FROM CUSTOM ORDER BY POINT;

UPDATE CUSTOM SET POINT = 131 WHERE USERID = 'nn4942';

----------------------------------------------------------------------------------

SELECT USERID, USERNAME, ADDR1, SCHOL FROM CUSTOM
WHERE USERID IN(SELECT USERID FROM COMPANY WHERE COMPANY LIKE '현대자동차%');

SELECT USERID, USERNAME, ADDR1, SCHOL FROM CUSTOM
WHERE USERID  = ANY(SELECT USERID FROM COMPANY WHERE COMPANY LIKE '현대자동차%');

SELECT USERID, USERNAME, ADDR1, SCHOL FROM CUSTOM
WHERE USERID NOT IN (SELECT USERID FROM COMPANYWHERE COMPANY LIKE '현대자동차%');

--SELECT USERID, USERNAME, ADDR1, SCHOL FROM CUSTOM
--WHERE USERID != ANY (SELECT USERID FROM COMPANY WHERE COMPANY LIKE '현대자동차%');

SELECT USERID, USERNAME, ADDR1, SCHOL FROM CUSTOM
WHERE USERID <>ALL(SELECT USERID FROM COMPANY WHERE COMPANY LIKE '현대자동차%');
----------------------------------------------------------------------------------

SELECT USERID, USERNAME, ADDR1, SCHOL FROM CUSTOM
WHERE USERID IN(SELECT USERID FROM COMPANY WHERE COMPANY LIKE '현대자동차%');

--상관쿼리
SELECT USERID, USERNAME, ADDR1, SCHOL FROM CUSTOM
WHERE EXISTS --EXITSTS나오면 상관쿼리라고 생각하면 ?
(SELECT * FROM COMPANY WHERE USERID = CUSTOM.USERID
--FROM CUSTOM와 CUSTOM.USERID의 CUSTOM이 같아야?
AND COMPANY LIKE '현대자동차%');

SELECT USERID, USERNAME, ADDR1, SCHOL FROM CUSTOM
WHERE NOT EXISTS --EXITSTS나오면 상관쿼리라고 생각하면 ?
(SELECT * FROM COMPANY WHERE USERID = CUSTOM.USERID
AND COMPANY LIKE '현대자동차%');

------------------------------------------------------------------------------------
SELECT * FROM CUSTOM WHERE ADDR1 = '경기도' AND AGE <= 20;

SELECT * FROM (SELECT * FROM CUSTOM WHERE ADDR1 = '경기도')A;

SELECT * FROM (SELECT * FROM CUSTOM WHERE ADDR1 = '경기도')A
WHERE A.AGE <= 20;
-------------------------------------------------------------------------------------
--PAIR 와이즈?--KIM 파일로 가서 확인해보자


